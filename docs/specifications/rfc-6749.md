# [RFC 6749] The OAuth 2.0 Authorization Framework

## 시작하기 전에

이 문서는 [[RFC 6749] The OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749)를 한글로 번역한 문서이다.

구글 검색을 신뢰하는 입장에서, RFC 6749 한글 번역을 검색했을 때 첫 페이지에서 완전히 번역된 문서를 찾을 수 없었기 때문에 **널리 공개된 한글 번역본이 존재하지 않는다고 판단**했다. 그래서 직접 번역을 하고 결과를 공유하고자 한다.

문서는 아래의 경우에 영문을 병행 표기했다.

1. 중요한 개념 또는 고유 명사
2. RFC 2119를 따르는 용어(MUST, MAY, SHOULD 등)

특히, 1번에 해당하는 중요한 고유 명사는 눈에 익도록 친숙하게 받아들이기를 권한다. 차후에 OAuth 2.0을 구현하는 다른 영문 문서를 볼 때 혼동하지 않고 받아들일 수 있다.

> **_예시 )_**  
> 권한 부여 서버(authorization server)  
> 권한 부여(authorization grant)  
> 공개 클라이언트(public client)  
> 암시적 권한 부여(implicit grant)

2번의 경우 명세서의 섹션 1.9의 표기 규칙에 설명되어 있다. 간단히 MUST는 필수, SHOULD는 권장, MAY는 허용의 의미로 사용되며, 정확한 의미는 [RFC 2119](https://datatracker.ietf.org/doc/html/rfc2119)를 따른다.

### 번역 범위

전체 문서를 처음부터 끝까지 번역하는 것을 목적으로 했으며, 불필요하다고 생각되는 극히 일부만 생략했다.

1. 섹션 11. IANA Considerations: 액세스 토큰 유형, 매개변수, 권한 부여 엔드포인트 응답 유형을 IANA 레지스트리에 등록하는 방법이 설명되어 있는데, OAuth 2.0를 이해하는 것 자체와는 무관하기 때문에 생략했다. 이 내용이 필요한 독자라면 원문을 읽을 수 있을 것이라고 생각된다.
2. Appendix A의 하위 항목: 매개 변수 형식만을 설명하기 때문에 번역하지 않아도 이해할 수 있다.
3. Appendix C 감사 인사
4. 과정을 설명하는 그림들: 중요한 개념 또는 고유 명사와 화살표만으로 구성된 그림이기 때문에, 영문으로 알고 있는 것이 바람직하다고 생각된다. 그림 주변에서 앞서 언급한 병행 표기를 했기 때문에 이해하기에 어려움이 없을 것으로 생각한다.
5. 각 섹션의 제목: 대부분 중요한 고유 명사로 이루어져 영문으로 보는게 좋다고 판단한다. 원문과 비교할 때도 영문으로 표기되어 있는 편이 유리하다. 용어가 생소할 수 있는 일부 경우에는 괄호 안에 한글을 병행 표기했다.

위에서 언급한 영문 병행 표기 부분과 의도적으로 미번역한 부분을 제외하면, **문서 처음부터 끝까지 모두 한글로 번역 되었음을 보장**하며 한글 사용자가 이 명세서(RFC 6749)를 이해하기 충분할 것으로 기대한다.

### 라이센스

RFC 6749는 RFC 5378(BCP 78)에 따라 IETF Trust가 소유하는 저작권을 포함하고 있다. 번역본인 이 문서는 공식적인 것이 아니며, 오역이 있을 수 있다. 번역본의 저작권은 번역자에게 있으며, 번역자의 정보는 다음과 같다.

번역자: Jihyeon Kim  
연락처: develop3357@gmail.com  
번역일: 2023-08-18

RFC 문서의 번역본을 사용하거나 배포하려면, RFC 5378 (BCP 78)의 조건을 준수해야 한다. RFC 5378(BCP 78)의 전문은 다음 링크에서 확인할 수 있다.

https://www.rfc-editor.org/info/bcp78

---

# [RFC 6749] The OAuth 2.0 Authorization Framework

## 개요

Abstract

OAuth 2.0 권한 부여 프레임워크를 사용하면 리소스 소유자 대신에 HTTP 서비스와의 상호 작용을 조율하거나, 타사 애플리케이션이 자체적으로 액세스 권한을 얻도록 하여 타사 애플리케이션이 HTTP 서비스에 대한 제한적인 액세스를 권한을 얻도록 할 수 있다. 이 명세서는 [RFC 5849](https://datatracker.ietf.org/doc/html/rfc5849)에 설명되어 있는 OAuth 1.0 프로토콜을 대체하고 폐기한다.

Status of This Memo

이것은 인터넷 표준 트랙 문서(Internet Standards Track document)이다.

이 문서는 인터넷 표준화 기구(IETF: Internet Engineering Task Force)의 제품이다. 이 문서는 IETF 커뮤니티의 합의를 나타낸다. 문서는 공개적인 리뷰와 인터넷 엔지니어링 운영 그룹(IESG: Internet Engineering Steering Group)의 발행 승인을 받았다. 인터넷 표준에 대한 추가적인 정보는 [Section 2 of RFC 5741](https://datatracker.ietf.org/doc/html/rfc5741#section-2)에서 확인할 수 있다.

이 문서의 현재 상태, 오류, 피드백을 제공하는 방법은 https://www.rfc-editor.org/info/rfc6749 에서 확인할 수 있다.

Copyright Notice

Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.

이 문서는 [BCP 78](https://datatracker.ietf.org/doc/html/bcp78) 및 문서를 발행하는 시점에 유효한 IETF 문서([http://trustee.ietf.org/license-info](http://trustee.ietf.org/license-info))에 관한 IETF 트러스트의 법적 조항을 따른다. 이 문서와 관련해 당신의 권리와 제약을 설명하기 때문에 그 문서들을 주의깊게 검토하기 바란다. 문서에서 추출한 코드 구성요소는 Trust Legal Providions의 섹션 4.e에 설명된 것처럼 Simplified BSD 라이센스 텍스트를 포함해야 하고 Simplified BSD 라이선스에서 설명된 보증 없이 제공된다.

Table of Contents

(생략)

## 1. Introduction

전통적인 서버-클라이언트 인증 모델에서 클라이언트는 리소스 소유자의 자격증명으로 서버와 인증하여 제한된 리소스에 접근 요청을 한다. 타사 애플리케이션에 제한된 리소스에 대한 접근을 부여하기 위해서는 리소스 소유자가 자신의 자격증명을 타사와 공유한다. 이것은 여러 문제와 한계를 유발한다.

- 타사 애플리케이션은 차후 사용에 대비해 리소스 소유자의 자격 증명을 저장해야 하며, 일반적으로 평문으로 비밀번호를 저장한다.
- 비밀번호에 내재된 보안 취약점에도 불구하고 서버가 비밀번호 인증을 지원해야 한다.
- 타사 애플리케이션이 리소스 소유자의 보호된 리소스에 대해서 지나치게 광범위한 접근을 얻게 되며, 리소스 소유자는 기한을 제한하거나 리소스의 일부분으로 접근을 한정시킬 수 없다.
- 리소스 소유자는 모든 타사의 권한을 취소하지 않고서는 개별 타사 애플리케이션의 권한만 취소시킬 수 없고, 그렇게 하려면 타사의 비밀번호를 바꿀 수밖에 없다.
- 타사 애플리케이션의 손상은 최종 사용자의 비밀번호와 해당 비밀번호로 보호받는 모든 데이터의 손상을 초래한다.

OAuth는 권한 부여(authorization) 계층을 도입하고 리소스 소유자의 역할로부터 클라이언트의 역할을 분리하여 이런 문제들을 조정한다. OAuth에서 클라이언트는 리소스 소유자가 제어하고 리소스 서버가 호스팅하는 리소스에 접근을 요청하고 리소스 소유자와는 별개의 다른 자격증명을 발급받는다.

보호된 리소스에 접근을 위해 리소스 소유자의 자격증명을 사용하는 대신, 클라이언트는 액세스 토큰을 발급받는다. 액세스 토큰은 특정한 범위, 생명주기 및 다른 접근 속성을 나타내는 문자열이다. 액세스 토큰은 권한 부여 서버로부터 리소스 소유자의 동의 하에 타사 클라이언트에게 발행된다. 클라이언트는 리소스 서버가 호스팅하는 보호 리소스에 대한 접근을 하기 위해 액세스 토큰을 사용한다.

예를 들어 최종 사용자(리소스 소유자)는 자신의 아이디와 비밀번호를 공유하지 않고 프린트 서비스(클라이언트)에게 사진 공유 서비스(리소스 서버)에 저장된 자신의 사진에 대한 접근을 허가할 수 있다. 대신에 최종 사용자는 사진 공유 서비스가 신뢰하는 서버(권한 부여 서버)와 직접 인증하며, 권한 부여 서버에서 프린트 서비스에 한정된 자격 증명(액세스 토큰)을 발급한다.

이 명세서는 HTTP([RFC2616](https://datatracker.ietf.org/doc/html/rfc2616))와 함께 사용하도록 설계되었다. HTTP 이외의 범위에서 OAuth를 사용하는 것은 이 명세서의 범위를 벗어난다.

OAuth 1.0은 정보 문서로 발행되었으며 작은 임시 커뮤니티의 노력의 결과이다. 이 표준 트랙 명세는 OAuth 1.0 배포 경험과 추가적인 사용 사례, 그리고 IEFE 커뮤니티에서 수집한 확장성 요구사항을 기반으로 만들어졌다. OAuth 2.0 프로토콜은 1.0과 역호환되지 않는다. 두 버전에 네트워크상에 공존할 수 있으며 둘 모두를 지원하여 구현하도록 선택할 수 있다. 그러나 새로운 구현은 이 명세서를 따라 OAuth 2.0을 지원하고, OAuth 1.0은 기존의 배포를 지원하는데만 사용하도록 하는 것이 이 명세서의 의도이다. OAuth 2.0은 1.0과 구현 세부사항을 거의 공유하지 않는다. OAuth 1.0에 익숙한 구현자는 이 문서의 구조와 세부사항에 대해 어떠한 가정 없이 접근해야 한다.

### 1.1. Roles

OAuth는 4가지 역할을 정의한다.

리소스 소유자(resource owner)  
보호 리소스에 대해 접근 권한을 부여할 수 있는 실체. 리소스 소유자가 개인일 경우, 최종 사용자로 지칭한다.

리소스 서버(resource server)  
보호 리소스을 호스팅하고, 액세스 토큰을 사용해 보호 리소스에 대한 접근을 수용하고 응답할 수 있는 서버.

클라이언트(client)  
리소스 소유자 대신 그의 권한을 가지고 보호 리소스 요청을 생성하는 애플리케이션. "클라이언트" 라는 용어는 특정한 구현 특성(예: 애플리케이션이 서버, 데스크탑, 또는 기타 장치에서 구동되는지 여부)을 암시하지 않는다.

권한 부여 서버(authorization server)  
리소스 소유자를 인증하고 권한을 부여 받은 후에 클라이언트에게 액세스 토큰을 발행하는 서버.

권한 부여 서버와 리소스 서버 사이의 상호작용은 이 명세서의 범위를 넘는다. 권한 부여 서버는 리소스 서버와 동일한 서버이거나 분리된 개체일 수 있다. 단일 권한 부여 서버는 여러 리소스 서버에서 허용하는 액세스 토큰을 발행할 수 있다.

### 1.2. Protocol Flow

```
     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+
```

그림 1에서 묘사된 OAuth 2.0의 추상적 흐름은 네 역할 사이의 상호작용을 서술하며 아래의 단계를 포함한다:

(A) 클라이언트가 리소스 소유자로부터 권한 부여를 요청한다. 권한 부여 요청은 리소스 소유자에게 직접 생성될(화면에 나타남) 수도 있고, 중개 역할을 하는 권한 부여 서버를 통해 간접적으로 생성될 수도 있다.

(B) 클라이언트는 권한 부여(authorization grant)를 수신한다. 그것은 리소스 소유자의 권한 부여를 나타내는 자격증명이며, 이 사양에서 정의하는 네 가지 권한 부여 유형(grant type) 중 하나를 사용하거나 또는 확장 권한 부여 유형을 사용해 표현된다. 권한 부여 유형은 클라이언트가 권한을 요청하는데 사용하는 방법과 권한 부여 서버가 지원하는 유형에 따라 다르다.

(C) 클라이언트는 권한 부여 서버로 인증하고 권한 부여(authorization grant)를 제시하여 액세스 토큰을 요청한다.

(D) 권한 부여 서버는 클라이언트를 인증하고 권한 부여(authorization grant)를 검증해서, 유효하다면 액세스 토큰을 발급한다.

(E) 클라이언트는 리소스 서버의 보호된 리소스를 요청하고 액세스 토큰을 제시하여 인증한다.

(F) 리소스 서버는 액세스 토큰을 검증하고, 유효하다면 요청에 응한다.

클라이언트가 리소스 소유자에게 권한 부여(authorization grant)를 요청(A, B 단계에 묘사)하는 바람직한 방법은 권한 부여 서버를 중개자로 사용하는 것인데, 이것은 섹션 4.1의 그림 3에 묘사되어 있다.

### 1.3. Authorization Grant

권한 부여(authorization grant)란 클라이언트가 액세스 토큰을 얻기 위해 사용하는, 리소스 소유자의 권한 부여(자신의 보호 리소스에 대한 접근)를 나타내는 자격증명이다. 이 명세서는 권한 부여 코드(authorization code), 암시적(implicit), 리소스 소유자 비밀번호 자격증명(resource owner password credentials), 클라이언트 자격증명(client credentials) 네 가지 권한 부여 유형(grant type) 및 추가적인 유형에 대한 확장성 메커니즘을 정의한다.

#### 1.3.1. Authorization Code

권한 부여 코드(authorization code)는 권한 부여 서버를 클라이언트와 리소스 소유자 사이의 중재자로 사용하여 얻는다. 클라이언트는 리소스 소유자에게 직접 권한 부여를 요청하지 않고 권한 부여 서버로 이동시킨 다음([RFC2616](https://datatracker.ietf.org/doc/html/rfc2616)에 정의된 리소스 소유자의 사용자 에이전트를 통해), 리소스 소유자가 권한 부여 코드와 함께 클라이언트로 되돌아가도록 한다.

리소스 소유자가 권한 부여 코드(authorization code)를 가지고 클라이언트에게 돌아가도록 하기 전에, 권한 부여 서버는 리소스 소유자를 인증하고 권한을 얻는다. 리소스 소유자는 권한 부여 서버하고만 인증하기 때문에 리소스 소유자의 자격증명은 클라이언트와 공유되지 않는다.

권한 부여 코드(authorization code)는 몇 가지 중요한 보안적 혜택을 제공하는데, 이를테면 클라이언트를 인증하는 기능과, 액세스 토큰을 리소스 소유자의 사용자 에이전트를 통하지 않고 클라이언트로 직접 전달하여 리소스 소유자를 포함한 다른 곳에 잠재적으로 노출하지 않는 것이다.

#### 1.3.2. Implicit

암시적 권한 부여(implicit grant)는 자바스크립트 같은 스크립트 언어를 사용해 브라우저 상에서 구현된 클라이언트를 위해 최적화된, 단순화된 권한 부여 코드(authorization code) 흐름이다. 암시적 흐름에서는 클라이언트에게 권한 부여 코드(authorization code)를 발급하지 않고, 클라이언트는 액세스 토큰을 직접 발급 받는다(리소스 소유자의 권한 부여의 결과로). 권한 부여 코드(authorization code) 같은 중간 단계의 자격증명(권한 부여 코드 같은)이 발급되지 않기 때문에 이 권한 부여 유형(grant type)은 암시적(implicit)이라고 한다.

암시적 권한 부여(implicit grant) 흐름으로 액세스 토큰을 발급할 때, 권한 부여 서버(authorization server)는 클라이언트를 인증하지 않는다. 경우에 따라 클라이언트로 액세스 토큰을 전달할 때 사용되는 리디렉션 URI를 통해 클라이언트 신원을 검증할 수 있다. 리소스 소유자 또는 리소스 소유자의 사용자 에이전트에 접근할 수 있는 다른 애플리케이션에 액세스 토큰이 노출될 수 있다.

암시적 권한 부여(implicit grant)는 일부 클라이언트(브라우저 내장 애플리케이션으로 구현된 클라이언트처럼)의 반응성과 효율성을 향상할 수 있는데, 액세스 토큰을 얻기 위해 왕복으로 오가는 횟수를 줄여주기 때문이다. 그러나 섹션 10.3과 10.16에 설명된 것처럼 이런 편리한 점은 암시적 권한 부여를 사용하는 것의 보안적인 의미와 비교하여 평가되어야 하며, 특히 권한 부여 코드(authorization code grant) 방식이 사용 가능할 때는 더욱 그렇다.

#### 1.3.3. Resource Owner Password Credentials

리소스 소유자 비밀번호 자격증명(예: username 과 password)은 액세스 토큰을 얻기 위해 직접적인 권한 부여(authorization grant)로써 사용될 수 있다. 자격증명은 리소스 소유자와 클라이언트 사이에 높은 수준의 신뢰가 존재할 때만 사용되어야 하며(예: 클라이언트가 디바이스 운영 체제의 일부이거나 높은 특권을 가진 애플리케이션일 때), 또한 권한 부여 코드(authorization code) 같은 다른 권한 부여 유형이 사용할 수 없을 때여야 한다.

이 권한 부여 유형은 클라이언트가 리소스 소유자의 자격증명에 직접 액세스 하도록 하지만, 리소스 소유자의 자격증명은 액세스 토큰을 교환하기 위해 단 한번의 요청에서만 사용된다. 이 권한 부여 유형은 클라이언트의 자격증명을 수명이 긴 액세스 토큰 또는 리프레시 토큰과 교환하여, 클라이언트가 차후 사용을 위해 리소스 소유자의 자격증명을 저장할 필요성을 제거할 수 있다.

#### 1.3.4. Client Credentials

클라이언트 자격증명(또는 클라이언트 인증의 다른 형식)은 클라이언트의 제어 하에 있는 보호 리소스, 또는 권한 부여 서버가 사전에 설정한 보호 리소스으로 권한 부여 범위가 한정될 때 권한 부여 유형으로 사용될 수 있다. 일반적으로 클라이언트 자격증명 유형이 사용되는 경우는, 클라이언트가 스스로를 대신하여 행동할 때(클라이언트 자신이 리소스 소유자일 때) 또는 권한 부여 서버가 미리 설정한 권한 부여를 기반으로 보호 리소스에 대해 클라이언트가 요청할 때이다.

### 1.4. Access Token

액세스 토큰은 보호 리소스에 접근할 때 사용되는 자격증명이다. 액세스 토큰은 클라이언트에게 발급된 권한 부여를 나타내는 문자열이다. 이 문자열은 보통 클라이언트에게는 불투명하다. 토큰은 리소스 소유자가 허가한 특정한 범위와 액세스 기간을 표현하며, 리소스 서버와 권한 부여 서버에 의해 시행된다.

토큰은 권한 부여 정보를 얻기 위해 사용되는 식별자로 표현되거나, 검증 가능한 방식으로 권한 부여 정보를 스스로 포함할 수 있다(예: 데이터와 시그니쳐로 구성된 토큰 문자열). 클라이언트가 토큰을 사용하기 위해서 이 명세서의 범위를 넘는 추가적인 인증 자격증명을 요구할 수 있다.

액세스 토큰은 리소스 서버가 이해할 수 있는 단일 토큰으로 다른 권한 부여 구조(예: username과 password)를 대체하는 추상적 계층을 제공한다. 이런 추상적 계층은 액세스 토큰을 발급하기 위해 사용되는 권한 부여(authorization grant)보다 더 제한적으로 액세스 토큰을 발급할 수 있도록 하며, 리소스 서버가 광범위한 인증 방법을 이해할 필요성도 제거해준다.

액세스 토큰은 리소스 서버의 보안 요구사항에 따라 다양한 형식, 구조, 활용 방법(예: 암호화 속성)을 가질 수 있다. 액세스 토큰 속성과 보호 리소스에 접근하는 방법은 이 명세서의 범위를 벗어나며, [RFC6750](https://datatracker.ietf.org/doc/html/rfc6750) 같은 동반 명세에 정의되어 있다.

### 1.5. Refresh Token

리프레시 토큰은 액세스 토큰을 얻기 위해 사용되는 자격증명이다. 리프레시 토큰은 자격 증명 서버가 클라이언트에 발급한다. 현재 액세스 토큰이 유효하지 않거나 만료 되었을 때 새로운 액세스 토큰을 얻기 위해서나, 또는 같거나 더 좁은 범위의 액세스 토큰을 추가로 얻기 위해서 사용된다(액세스 토큰은 리소스 소유자가 부여한 권한보다 더 짧은 생명주기와 좁은 권한을 가질 수 있다). 리프레시 토큰을 발급하는 것은 권한 부여 서버의 재량에 의한 선택 사항이다. 권한 부여 서버가 리프레시 토큰을 발급한다면, 액세스 토큰이 언제 발급된 것인지를 포함한다(예: 그림 1의 과정 D).

리프레시 토큰은 리소스 소유자가 클라이언트에게 부여한 권한을 표현하는 문자열이다. 문자열은 일반적으로 클라이언트에게 불투명하다. 이 토큰은 권한 부여 정보를 검색하기 위해 사용하는 식별자를 나타낸다. 액세스 토큰과는 다르게 리프레시 토큰은 권한 부여 서버에서만 사용하도록 의도되었으며 리소스 서버로 전송되지 않는다.

```
  +--------+                                           +---------------+
  |        |--(A)------- Authorization Grant --------->|               |
  |        |                                           |               |
  |        |<-(B)----------- Access Token -------------|               |
  |        |               & Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token ----------->|               |
  |        |                                           |               |
  |        |<-(H)----------- Access Token -------------|               |
  +--------+           & Optional Refresh Token        +---------------+

               Figure 2: Refreshing an Expired Access Token
```

그림 2에 묘사된 흐름은 아래의 과정을 포함한다.

(A) 클라이언트는 권한 부여 서버와 인증하고 권한 부여(authorization grant)를 제시하여 액세스 토큰을 요청한다.

(B) 권한 부여 서버는 클라이언트를 인증하고 권한 부여(authorization grant)를 검증해서, 유효하다면 액세스 토큰과 리프레시 토큰을 발급한다.

(C) 클라이언트는 액세스 토큰을 제시하여 리소스 서버에게 보호 리소스 요청을 생성한다.

(D) 리소스 서버는 액세스 토큰을 검증하고, 유효하다면 요청에 응한다.

(E) 과정 (C)와 (D)는 액세스 토큰이 만료될 때까지 반복한다. 클라이언트가 액세스 토큰이 만료될 것을 안다면 과정 (G)로 넘어가고, 그렇지 않다면 또다른 보호 리소스 요청을 생성한다.

(F) 액세스 토큰이 유효하지 않기 때문에 리소스 서버는 유효하지 않은 토큰 에러를 리턴한다.

(G) 클라이언트는 권한 부여 서버와 인증하고 리프레시 토큰을 제시하여 새로운 액세스 토큰을 요청한다. 클라이언트 인증 요청은 클라이언트 유형과 권한 부여 서버 정책에 근거한다.

(H) 권한 부여 서버가 클라이언트를 인증하고 리프레시 토큰을 검증하여, 유효하다면 새로운 액세스 토큰을 발급한다(선택 사항으로 새 리프레시 토큰도 발급한다).

과정 (C), (D), (E), (F)는 섹션 7에 설명된대로 이 명세서의 범위를 벗어난다.

### 1.6. TLS Version

이 명세서에서 전송 계층 보안(TLS: Transport Layer Security)가 사용될 때마다 TLS의 적절한 버전은 광범위한 배포 및 알려진 보안 취약점에 따라 시간적으로 달라질 것이다. 이 문서를 작성할 때는 TLS 버전 1.2 [RFC5246](https://datatracker.ietf.org/doc/html/rfc5246)가 최신 버전이지만, 배포 기반이 매우 제한되어 있고 구현에 즉시 사용하지 못할 수 있다. TLS 버전 1.0 [RFC2246](https://datatracker.ietf.org/doc/html/rfc2246)이 가장 널리 배포된 버전이며 가장 광범위한 상호운용성을 제공할 것이다.

구현자는 자신의 보안 요구사항을 충족하는 추가적인 전송 계층 보안 메커니즘을 지원할 수 있다(MAY).

### 1.7. Http Redirections

이 명세서는 클라이언트 또는 자격 증명 서버가 리소스 소유자의 사용자 에이전트를 다른 목적지로 보내는 광범위한 HTTP 리디렉션을 사용한다. 이 명세서에서는 HTTP 302 상태 코드의 사용을 예로 들지만, 사용자 에이전트를 통해 사용할 수 있는 다른 리디렉션 방법도 하용되며, 구현 세부사항으로 간주한다.

### 1.8. Interoperability (상호운용성)

OAuth 2.0은 잘 정의된 보안 속성을 포함해 풍부한 권한 부여 프레임워크를 제공한다. 그러나 많은 선택적 구성 요소를 가진 풍부하고 높은 확장성을 가진 프레임워크로서, 이 명세서는 상호운용 불가능한 광범위한 구현을 생산할 가능성이 있다.

추가로 이 명세서는 일부 구성 요소를 부분적으로 또는 완전히 정의하지 않는다(예: 클라이언트 등록, 권한 부여 서버 능력, 엔드포인트 디스커버리). 이런 구성 요소 없이는 상호운용을 위해 특정 권한 부여 서버와 리소스 서버의 세부사항에 대해 클라이언트틀 수동으로 구체적으로 설정해야 한다.

이 프레임워크는 향후 작업에서 완전한 웹 규모의 상호운용성을 달성하기 위해 필요한 규범적 프로필과 확장을 정의할 것이라는 분명한 기대를 가지고 설계되었다.

### 1.9. Notational Conventions (표기 규칙)

이 사양에서 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", "OPTIONAL" 키워드는 [RFC2119](https://datatracker.ietf.org/doc/html/rfc2119)에 설명된대로 해석된다.

이 사양은 [RFC5234](https://datatracker.ietf.org/doc/html/rfc5234)의 Augmented Backus-Naur Form (ABNF) 표기법을 사용한다. 추가로 URI-reference의 규칙은 [RFC3986](https://datatracker.ietf.org/doc/html/rfc3986) "Uniform Resource Identifier (URI): Generic Syntax"에 포함되어 있다.

특정 보안관련 용어는 [RFC4949](https://datatracker.ietf.org/doc/html/rfc4949)의 관점에서 이해할 수 있다. 이런 용어에는 다음이 포함되지만 이에 국한되지는 않는다. "attack", "authentication", "authorization", "certificate", "confidentiality", "credential", "encryption", "identity", "sign", "signature", "trust", "validate", "verify"

달리 명시되지 않는 한 모든 프로토콜 매개변수 이름과 값은 대소문자를 구분한다.

## 2. Client Registration

프로토콜을 시작하기 전에 클라이언트가 권한 부여 서버에 등록된다. 클라이언트가 권한 부여 서버에 등록하는 방법은 이 사양의 범위를 벗어나지만 일반적으로 HTML 등록 양식과 최종 사용자의 상호작용을 포함한다.

클라이언트 등록은 클라이언트와 권한 부여 서버의 직접적인 상호작용을 요구하지 않는다. 권한 부여 서버가 지원하는 경우 다른 수단에 의존해 신뢰 구축 및 필요한 클라이언트의 속성(예: 리디렉션 URI, 클라이언트 유형)을 얻을 수 있다. 예를 들어 자기 자신 또는 타사가 발행한 권리를 행사하거나, 신뢰할 수 있는 채널을 사용해 클라이언트 발견을 수행하는 권한 부여 서버에 의해서도 등록을 수행할 수 있다.

클라이언트를 등록할 때 클라이언트 개발자는 반드시 아래를 따른다(SHALL):

- 섹션 2.1에 설명된 것처럼 클라이언트 유형을 특정한다.
- 섹션 3.1.2에 설명된 것처럼 클라이언트 리디렉션 URI를 제공한다.
- 권한 부여 서버가 요구하는 모든 정보(예: 애플리케이션 이름, 웹사이트, 세부사항, 로고 이미지, 법적 조건 동의)를 포함한다.

#### 2.1. Client Types

OAuth는 권한 부여 서버로 안전하게 인증하는 기능에 따라 두 가지 클라이언트 유형을 정의한다(예: 클라이언트 자신의 자격증명의 기밀성을 유지하는 기능).

confidential  
자격증명의 기밀성을 유지할 수 있는 클라이언트(예: 클라이언트 자격 증명으로 접근이 제한되는 보안 서버에 구현된 클라이언트), 또는 다른 수단을 사용해 보안 인증 할 수 있는 클라이언트

public  
자신의 자격증명의 기밀성을 유지할 수 없는 클라이언트(예: 네이티브 애플리케이션 또는 웹브라우저 기반 애플리케이션처럼 리소스 소유자가 사용하는 디바이스에서 실행되는 클라이언트), 또는 어떤 수단을 통해서도 보안 클라이언트 인증을 할 수 없는 클라이언트

클라이언트 유형 지정은 권한 부여 서버의 보안 인증에 대한 정의와 클라이언트 자격증명의 노출 허용 수준을 기반으로 한다. 권한 부여 서버는 클라이언트 유형에 대해 가정하지 않을 것을 권장한다(SHOULD NOT).

클라이언트는 각각이 다른 클라이언트 유형과 보안 컨텍스트를 갖는 분산된 구성요소의 집합으로 구현될 수 있다(예: 기밀 유지된 서버 기반 컴포넌트와 공개된 브라우저 기반 컴포넌트 둘 다로 구성된 분산된 클라이언트). 권한 부여 서버가 해당 클라이언트를 지원하지 않거나, 등록에 관한 지침을 제공하지 않는다면 클라이언트는 각각의 구성 요소를 별도의 클라이언트로 등록해야 한다.

이 명세서는 아래의 클라이언트 프로필을 중심으로 설계되었다.

web application  
웹 애플리케이션은 웹 서버에서 실행되는 기밀 클라이언트(confidential client)이다. 리소스 소유자는 자신이 사용하는 디바이스의 사용자 에이전트에서 렌더링되는 HTML 사용자 인터페이스를 통해 클라이언트에 접근한다. 클라이언트 자격증명과 클라이언트에게 발급되는 모든 액세스 토큰은 웹 서버에 저장되며 리소스 소유자에게 노출되거나 리소스 소유자가 액세스 할 수 없다.

user-agent-based application  
사용자 에이전트 기반 애플리케이션은 공개된 클라이언트(public client)이며 웹 서버로부터 다운로드 받고 리소스 소유자의 디바이스의 사용자 에이전트(예: 웹 브라우저)에서 실행된다. 프로토콜 데이터와 자격증명은 리소스 소유자가 쉽게 액세스 할 수 있다(시각적으로 보이기도 함). 이런 애플리케이션은 사용자 에이전트 내에 상주하므로 권한을 요청할 때 사용자 에이전트 기능을 원활하게 사용할 수 있다.

native application  
네이티브 애플리케이션은 리소스 소유자가 사용하는 디바이스에 설치되어 실행되는 공개된 클라이언트(public client)이다. 프로토콜 데이터와 자격 증명은 리소스 소유자가 접근할 수 있다. 애플리케이션에 포함된 클라이언트 자격증명은 모두 추출할 수 있다고 가정한다. 반면에 액세스 토큰이나 리프레시 토큰처럼 동적으로 발급되는 자격증명은 허용 가능한 수준의 보호를 받을 수 있다. 최소한 이런 자격 증명은 애플리케이션과 상호작용할 수 있는 적대적인 서버로부터 보호받을 수 있다. 일부 플랫폼에서 이러한 자격 증명은 동일한 디바이스에 상주하는 다른 애플리케이션으로부터 보호받을 수 있다.

### 2.2. Client Identifier

권한 부여 서버는 등록된 클라이언트에게 클라이언트 식별자(클라이언트가 제공한 등록 정보를 나타내는 고유한 문자열)를 발급한다. 클라이언트 식별자는 비밀이 아니며, 리소스 소유자에게 노출된다. 클라이언트 식별자는 클라이언트 인증을 위해 단독으로 사용될 수 없다(MUST NOT). 클라이언트 식별자는 권한 부여 서버에서 고유한 값이다.

클라이언트 식별자 문자열의 길이는 이 명세서에서 정의하지 않는다. 클라이언트는 식별자의 길이에 대해 가정하지 않아야 한다. 권한 부여 서버는 자신이 발급하는 모든 식별자의 길이에 대해 문서화해야 한다.

### 2.3. Client Authentication

클라이언트 유형이 기밀(confidential)인 경우, 클라이언트와 권한 부여 서버는 자신의 보안 요구사항을 충족하는 클라이언트 인증 방법을 구성한다. 권한 부여 서버는 이 보안 요구사항을 만족하는 모든 형식의 클라이언트 인증을 허용할 수 있다(MAY).

일반적으로 기밀 클라이언트(confidential client)는 자격 증명 서버와 인증하는데 사용되는 클라이언트 자격증명의 집합을 발급(또는 구성)한다. (예: 비밀번호, 공개/비밀 키 쌍)

권한 부여 서버는 공개 클라이언트(public client)와의 클라이언트 인증 방법을 구성할 수 있다(MAY). 그러나 권한 부여 서버는 클라이언트의 식별 목적으로 공개 클라이언트(public client) 인증에 의존해서는 안 된다(MUST NOT).

클라이언트는 각 요청에서 대해 둘 이상의 인증 방법을 사용할 수 없다(MUST NOT).

#### 2.3.1. Client Password

클라이언트 비밀번호를 소유한 클라이언트는 권한 부여 서버와 인증하기 위해 [RFC2617](https://datatracker.ietf.org/doc/html/rfc2617)에 정의된 HTTP 기본 인증 체계를 사용할 수 있다(MAY). 클라이언트 식별자는 [Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B)에 따라 "application/x-www-form-urlencoded" 인코딩 알고리즘을 사용해 인코딩되며, 인코딩된 값은 username으로 사용된다. 클라이언트 비밀번호는 동일한 알고리즘으로 인코딩되고 비밀번호로 사용된다. 권한 부여 서버는 클라이언트 비밀번호를 발급받은 클라이언트를 인증하기 위해 HTTP 기본 인증 체계를 지원해야 한다(MUST).

예시:

```
Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3
```

이 방법 대신 권한 부여 서버는 아래의 매개변수를 사용해 request-body에 클라이언트 자격증명을 포함시키는 방법을 지원할 수 있다(MAY).

client_id
필수값. 섹션 2.2에 설명된, 등록 과정에서 클라이언트에게 발급되는 클라이언트 식별자

client_secret
필수값. 클라이언트 시크릿. 클라이언트는 클라이언트 시크릿이 빈 문자열인 경우 이 매개변수를 생략할 수 있다.

request-body에 두 파라미터를 사용해서 클라이언트 자격 증명을 포함하는 것은 권장되지 않으며, 클라이언트가 HTTP 기본 인증 체계(또는 다른 비밀번호 기반의 HTTP 인증 체계)를 직접 활용할 수 없을 때로 제한할 것을 권한다(SHOULD). 이 매개변수는 request-body에서만 전송할 수 있고, 요청 URI에는 포함되어서는 안 된다(MUST NOT).

body 매개변수를 사용해 액세스 토큰을 재발급하는 요청(섹션 6)의 예시:

```
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
&client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
```

권한 부여 서버는 비밀번호 인증을 사용하는 요청을 보낼 때 섹션 1.6에 서술된 것처럼 TLS의 사용을 반드시 요구해야한다(MUST).

이 클라이언트 인증 방식은 비밀번호를 포함하기 때문에, 권한 부여 서버는 이 방법을 활용하는 모든 엔드포인트에서 무차별 대입 공격을 방어해야 한다(MUST).

#### 2.3.2. Other Authentication Methods

권한 부여 서버는 보안 요구사항과 일치하는 모든 적합한 HTTP 인증 체계를 지원할 수 있다(MAY). 다른 인증 방법을 사용할 때, 권한 부여 서버는 반드시 클라이언트 식별자(등록 기록)와 인증 체계 사이의 매핑을 정의해야 한다.

### 2.4. Unregistered Clients

이 명세서는 등록되지 않은 클라이언트의 사용을 배제하지 않는다. 그러나 그런 클라이언트를 사용하는 것은 이 명세서의 범위를 벗어나며, 추가적인 보안 분석과 그 상호운용성 영향에 대한 분석을 요구한다.

## 3. Protocol Endpoints

권한 부여 프로세스는 권한 부여 서버의 두 엔드 포인트(HTTP 자원)를 활용한다.

- 권한 부여 엔드포인트(Authorization endpoint): 클라이언트가 사용자 에이전트 리디렉션을 통해 리소스 소유자로부터 권한을 얻는데 사용
- 토큰 엔드포인트(Token endpoint): 일반적으로 클라이언트 인증과 함께 클라이언트가 권한 부여(authorization grant)를 액세스 토큰과 교환하는데 사용

또 하나의 클라이언트 엔드포인트를 활용한다.

- 리디렉션 엔드포인트(Redirection endpoint): 권한 부여 서버가 리소스 소유자의 사용자 에이전트를 통해 클라이언트에게 권한 부여 자격증명을 포함하는 응답을 리턴하는데 사용

모든 권한 부여 유형(authorization grant type)이 양쪽 엔드포인트를 활용하지 않는다. 확장 권한 부여 유형(grant type)은 필요에 따라 추가적인 엔드포인트를 정의할 수 있다.

### 3.1. Authorization Endpoint

권한 부여 엔드포인트는(authorization endpoint)는 리소스 소유자와 상호작용하고 권한 부여(authorization grant)를 얻는데 사용된다. 권한 부여 서버는 먼저 반드시 리소스 소유자의 신원을 검증해야 한다(MUST). 권한 부여 서버가 리소스 소유자를 인증하는 방법(예: username/password 로그인, 세션 쿠키)는 이 명세서의 범위를 벗어난다.

클라이언트가 인증 엔드포인트(authorization endpoint)의 위치를 얻는 방법은 이 명세서의 범위를 벗어나지만 일반적으로 그 위치는 서비스 문서에서 제공된다.

엔드포인트 URI는 "application/x-www-form-urlencoded" 형식([Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B))의 쿼리 구성요소([[RFC3986] Section 3.4](https://datatracker.ietf.org/doc/html/rfc3986#section-3.4))를 포함할 수 있으며(MAY), 이것은 쿼리 매개변수가 추가될 때도 반드시 유지되어야 한다(MUST). 엔드포인트 URI는 프래그먼트(fragment) 구성요소를 포함할 수 없다(MUST NOT).

권한 부여 엔드포인트(authorization endpoint)에 대한 요청은 사용자 인증과 자격증명을 평문으로 HTTP 응답으로 전송하기 때문에, 권한 부여 서버는 권한 부여 엔드포인트(authorization endpoint)에 대한 요청을 보낼 때 섹션 1.6에 설명된 것처럼 TLS의 사용을 반드시 요구해야 한다(MUST).

권한 부여 서버는 권한 부여 엔드포인트에서 HTTP "GET" [RFC2616](https://datatracker.ietf.org/doc/html/rfc2616) 요청을 반드시 지원해야 하며(MUST), "POST" 방식 요청도 지원할 수 있다(MAY).

값 없이 전송되는 매개변수는 해당 요청에서 생략된 것처럼 취급해야 한다(MUST). 권한 부여 서버는 식별되지 않은 요청 매개변수를 무시해야 한다(MUST). 요청과 응답 매개변수는 두 번 이상 포함되어서는 안 된다(MUST NOT).

#### 3.1.1. Response Type

권한 부여 엔드포인트는 권한 부여 코드(authorization code)와 암시적(implicit) 권한 부여 유형(grant type) 흐름에서 사용된다. 클라이언트는 아래 매개변수를 사용해 원하는 권한 부여 유형(grant type)을 권한 부여 서버에게 알린다.

response_type  
필수값. 이 값은 "code"를 사용해 섹션 4.1.1에서 설명하는 권한 부여 코드(authorization code)를 요청하거나, "token"을 사용해 섹션 4.2.1에서 설명하는 액세스 토큰을 요청하거나(암시적 권한 부여 유형), 또는 섹션 8.4에서 설명하는 등록된 확장값 중 하나여야 한다(MUST).

확장 응답 유형은 공백(%x20)으로 구분된 값의 목록을 포함할 수 있는데(MAY), 값의 순서는 중요하지 않다(예: 응답 유형 "a b"는 "b a"와 동일함). 그런 복합적인 응답 유형의 의미는 그들 각각의 명세에 정의된다.

권한 부여 요청이 "response_type" 파라미터를 빠뜨리거나 응답 유형을 이해할 수 없는 경우, 권한 부여 서버는 섹션 4.1.2.1에 설명된 것처럼 반드시 에러 응답을 리턴해야 한다(MUST).

### 3.1.2. Redirection Endpoint

리소스 소유자와의 상호작용이 끝난 다음, 권한 부여 서버는 리소스 소유자의 사용자 에이전트를 클라이언트에게 되돌려 보낸다. 권한 부여 서버는 클라이언트 등록 과정 또는 권한 부여 요청을 생성할 때, 권한 부여 서버에서 이전에 설정된 클라이언트의 리디렉션 엔드포인트로 사용자 에이전트를 리디렉트한다.

리디렉션 엔드포인트 URI는 [[RFC3986] Section 4.3](https://datatracker.ietf.org/doc/html/rfc3986#section-4.3)에서 정의된 절대 URI여야 한다(MUST). 엔드포인트 URI는 "application/x-www-form-urlencoded" 포맷의([Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B)) 쿼리 구성요소([[RFC3986] Section 3.4](https://datatracker.ietf.org/doc/html/rfc3986#section-3.4))를 포함할 수 있으며(MAY), 이것은 쿼리 구성요소를 추가할 때도 유지되어야 한다(MUST). 엔드포인트 URI는 프래그먼트 구성 요소를 포함할 수 없다(MUST NOT).

##### 3.1.2.1. Endpoint Request Confidentiality

리디렉션 엔드포인트는 요청된 응답 유형이 "code" 또는 "token"이거나 리디렉션 요청이 공개된 네트워크 상에서 민감한 자격증명의 전송을 초래할 때, 섹션 1.6에서 설명하는 것처럼 TLS 사용하도록 요구할 것을 권장한다(SHOULD). 이 명세서가 작성될 당시에는 클라이언트에 TLS를 배포하도록 요구하는 것은 많은 클라이언트 개발자에게 중대한 장애물이었기 때문에, 이 명세서는 TLS 사용을 의무화하지 않는다. TLS를 사용할 수 없는 경우 권한 부여 서버는 리디렉션 하기 전 리소스 소유자에게 엔드포인트가 안전하지 않다는 점을 고지할 것을 권장한다(SHOULD). (예: 권한 부여 요청 과정에서 메시지를 표시)

전송 계층 보안의 부재는 클라이언트와 접근 권한 부여된 보호 리소스에 대한 심각한 보안 영향을 미칠 수 있다. 전송 보안 계층을 사용하는 것은 권한 부여 프로세스가 클라이언트가 최종 사용자 인증 위임 형식을 사용할 때 특히 중요하다(예: 타사 로그인 서비스).

##### 3.1.2.2. Registration Requirements

권한 부여 서버는 아래 클라이언트가 자신의 리디렉션 엔드포인트를 반드시 등록하도록 요구해야 한다(MUST).

- 공개된 클라이언트(public clients)
- 암시적 권한 부여 유형(Implicit grant type)을 활용하는 기밀 클라이언트(confidential clients)

권한 부여 서버는 모든 클라이언트가 권한 부여 엔드포인트를 활용하기 전에 반드시 자신의 리디렉션 엔드포인트를 등록하도록 요구하기를 권장한다(SHOULD).

권한 부여 서버는 클라이언트가 완전한 리디렉션 URI를 제공하도록 요구하기를 권장한다(SHOULD). (클라이언트는 요청 매개변수 "state"를 사용하여 요청별로 커스텀 할 수 있다(MAY)) 완전한 리디렉션 URI를 등록하도록 요구하는 것이 불가능하다면, 권한 부여 서버는 URI 체계, 권한, 경로의 등록을 요청하는 것을 권장한다(SHOULD). (클라이언트가 권한 부여를 요청할 때 리디렉션 URI 중 쿼리 구성요소만 동적으로 변경하도록 허용)

권한 부여 서버는 클라이언트가 다수의 리디렉션 엔드포인트를 등록하는 것을 허용할 수 있다(MAY).

리디렉션 URI 등록 요구를 하지 않으면, 섹션 10.15에 서술된 것처럼 공격자가 권한 부여 엔드포인트를 개방형 리디렉터로 사용할 수 있다.

##### 3.1.2.3. Dynamic Configuration

다수의 리디렉션 URI가 등록되어 있거나, 리디렉션 URI 중 일부만 등록되어 있거나, 또는 아무 리디렉션 URI도 등록되어 있지 않다면, 클라이언트는 권한 부여 요청에 "request_uri" 파라미터를 사용해 리디렉션 URI를 반드시 포함해야 한다(MUST).

권한 부여 요청에 리디렉션 URI가 포함된 경우, 리디렉션 URI가 하나라도 등록되었다면 권한 부여 서버는 [[RFC3986] Section 6](https://datatracker.ietf.org/doc/html/rfc3986#section-6)에 정의된 것처럼 등록된 리디렉션 URI(또는 URI 구성요소) 중 하나와 수신한 값이 일치하는지 반드시 비교해야 한다(MUST). 클라이언트 등록이 전체 리디렉션 URI를 포함하고 있다면 권한 부여 서버는 [[RFC3986] Section 6.2.1](https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.1)에 정의된 것처럼 간단한 문자열 비교를 사용해 반드시 두 URI를 비교해야 한다(MUST).

##### 3.1.2.4. Invalid Endpoint

누락 되었거나 유효하지 않거나, 또는 리디렉션 URI의 불일치로 인해 권한 부여 요청을 검증 실패했다면, 권한 부여 서버는 리소스 소유자에게 에러에 대해 알릴 것을 권장하며(SHOULD) 사용자 에이전트를 잘못된 리디렉션 URI로 자동으로 리디렉션 하지 않아야 한다(MUST NOT).

##### 3.1.2.5. Endpoint Content

클라이언트의 엔드포인트로 리디렉션 요청은 일반적으로 사용자 에이전트가 처리하는 HTML 문서로 응답하게 된다. 리디렉션 요청의 결과로 HTML 응답이 직접 제공된 경우, HTML 문서에 포함된 모든 스크립트는 리디렉션 URI와 거기 포함된 자격증명에 대한 완전한 접근 권한을 가지고 실행될 것이다.

클라이언트는 리디렉션 엔드포인트 응답에 어떠한 타사 스크립트(타사 분석도구, 소셜 플러그인, 광고 등)를 포함하지 않을 것을 권장한다(SHOULD NOT). 대신에 자격증명이 URI 또는 다른 어느 곳에서도 노출되지 않도록 해당 URI에서 자격증명을 추출하고 사용자 에이전트를 또다른 엔드포인트로 리디렉트 할 것을 권장한다(SHOULD). 만약 타사 스크립트가 포함된 경우 클라이언트는 자신의 스크립트(URI로부터 자격증명을 추출하고 제거하는데 사용)가 먼저 실행되도록 보장해야 한다(MUST).

### 3.2. Token Endpoint

토큰 엔드포인트는 클라이언트가 권한 부여(authorization grant) 또는 리프레시 토큰을 제시하여 액세스 토큰을 얻기 위해 사용된다. 토큰 엔드포인트는 암시적 권한 부여(implicit grant)유형을 제외한 다른 모든 권한 부여(authorization grant)에서 사용된다(암시적 권한 부여 유형에서는 액세스 토큰이 직접 발급되기 때문).

클라이언트가 토큰 엔드포인트의 위치를 얻는 방법은 이 명세서의 범위를 벗어나지만, 그 위치는 일반적으로 서비스 문서에서 제공된다.

엔드포인트 URI는 "application/x-www-form-urlencoded" 형식([Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B))의 쿼리 구성요소([[RFC3986] Section 3.4](https://datatracker.ietf.org/doc/html/rfc3986#section-3.4))를 포함할 수 있으며(MAY), 추가적인 쿼리 파라미터가 추가될 때도 유지되어야 한다(MUST). 엔드포인트 URI는 프래그먼트 구성요소를 포함할 수 없다(MUST NOT).

토큰 엔드포인트로의 요청은 HTTP 요청과 응답 안에서 평문화된 자격증명의 전송을 초래하기 때문에, 토큰 엔드포인트로 요청을 보낼 때 권한 부여 서버는 섹션 1.6에서 설명한 것처럼 TLS의 사용을 반드시 요구해야 한다(MUST).

클라이언트는 액세스 토큰 요청을 생성할 때 반드시 HTTP "POST" 방식을 사용해야 한다(MUST).

값 없이 전송되는 매개변수는 해당 요청에서 생략된 것처럼 취급해야 한다(MUST). 권한 부여 서버는 식별되지 않은 요청 매개변수를 무시해야 한다(MUST). 요청과 응답 매개변수는 두 번 이상 포함되어서는 안 된다(MUST NOT).

#### 3.2.1. Client Authentication

기밀 클라이언트(confidential client) 또는 클라이언트 자격증명을 발급하는 다른 클라이언트는 토큰 엔드포인트로 요청을 생성할 때 섹션 2.3에 설명된 것처럼 반드시 권한 부여 서버와 인증해야 한다(MUST). 클라이언트 인증은 아래를 위해 사용된다.

- 리프레시 토큰 및 권한 부여 코드(authorization code)와 그것을 발급한 클라이언트와의 결합을 강화한다. 클라이언트 인증은 안전하지 않은 채널을 통해 권한 부여 코드(authorization code)가 발송될 때나 전체 리디렉션 URI가 등록되지 않았을 때 중요하다.
- 클라이언트를 비활성화하거나 자격증명을 변경하는 방법으로 손상된 클라이언트를 복구하여, 공격자가 훔친 리프레시 토큰을 남용하지 못하도록 한다. 클라이언트 자격증명 한 집합만 변경하는 것이 리프레시 토큰 전체를 취소하는 것보다 훨씬 빠르다.
- 주기적으로 자격증명을 순환하도록 요구하는 인증 관리 우수사례를 구현하기 위해. 리프레시 토큰 전체를 순환하는 것은 어려울 수 있지만 클라이언트 자격증명 한 집합만 순환하는 것은 훨씬 쉽다.

토큰 엔드포인트로 요청을 보낼 때 클라이언트는 자기 자신을 식별하기 위해 "client_id" 요청 매개변수를 사용할 수 있다(MAY). 권한 부여 코드 방식("authorization_code", "grant_type")의 토큰 엔드포인트 요청에서, 인증되지 않은 클라이언트는 "client_id"를 반드시 발송하여(MUST) 다른 "client_id"를 가진 클라이언트에게 의도된 코드를 부주의하게 받아들이지 않도록 한다. 이 방법은 권한 부여 코드(authentication code) 교체로부터 클라이언트를 보호한다. (보호 리소스에 대한 추가적인 보안을 제공하지는 않는다.)

### 3.3. Access Token Scope

권한 부여 엔드포인트와 토큰 엔드포인트에서 클라이언트는 "scope" 요청 매개변수를 사용해 액세스 요청 범위를 지정할 수 있다. 이후 권한 부여 서버는 응답 매개변수 "scope"를 사용해 발급한 액세스 토큰의 범위에 대해 클라이언트에게 알린다.

scope 매개변수의 값은 공백으로 구분된 목록으로 표현되며 대소문자를 구분한다. 이 문자열은 권한 부여 서버에서 정의한다. 값이 여러개의 공백으로 구성되어 있을 때 그들의 순서는 중요하지 않으며, 각각의 문자열은 요청 범위에 접근 범위를 추가한다.

```text
scope       = scope-token *( SP scope-token )
scope-token = 1*( %x21 / %x23-5B / %x5D-7E )
```

권한 부여 서버의 정책 또는 리소스 소유자의 지시에 근거하여, 권한 부여 서버는 클라이언트가 요청한 범위의 전체 또는 일부분을 무시할 수 있다(MAY). 클라이언트가 요청한 범위와 발급된 액세스 토큰의 범위가 다르다면 권한 부여 서버는 응답 매개변수 "scope"를 포함해 실제로 허가된 범위를 클라이언트에게 알려야 한다(MUST).

인증을 요청할 때 클라이언트가 scope 매개변수를 누락했다면, 권한 부여 서버는 사전에 정의된 기본값으로 처리하거나, 잘못된 범위에 대한 요청을 실패해야 한다(MUST). 권한 부여 서버는 자신의 범위 요구사항과 기본값(정의된 경우)에 대해 문서화할 것을 권장한다(SHOULD).

## 4. Obtaining Authorization

액세스 토큰을 요청하기 위해 클라이언트는 리소스 소유자로부터 권한을 얻는다. 권한 부여는 권한 부여(authorization grant) 형식으로 표현되며, 클라이언트가 액세스 토큰을 요청하는데 사용된다. OAuth는 네 가지 권한 부여 유형(grant type)을 정의한다: `authorization_code`, `implicit`, `resource owner password credentials`, `client credentials`. OAuth는 추가적인 권한 부여 유형(grant type)을 정의하는 확장 메커니즘 또한 제공한다.

### 4.1. Authorization Code Grant

권한 부여 코드(authorization code grant) 유형은 액세스 토큰과 리프레시 토큰을 얻는데 사용되며, 기밀 클라이언트(confidential client)에 최적화되었다. 이것은 리디렉션 기반의 흐름이기 때문에, 클라이언트는 리소스 소유자의 사용자 에이전트(일반적으로 웹브라우저)와 상호작용 할 수 있어야 하고 권한 부여 서버로부터 (리디렉션을 통해) 들어오는 요청을 받아들일 수 있어야 한다.

```
     +----------+
     | Resource |
     |   Owner  |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier      +---------------+
     |         -+----(A)-- & Redirection URI ---->|               |
     |  User-   |                                 | Authorization |
     |  Agent  -+----(B)-- User authenticates --->|     Server    |
     |          |                                 |               |
     |         -+----(C)-- Authorization Code ---<|               |
     +-|----|---+                                 +---------------+
       |    |                                         ^      v
      (A)  (C)                                        |      |
       |    |                                         |      |
       ^    v                                         |      |
     +---------+                                      |      |
     |         |>---(D)-- Authorization Code ---------'      |
     |  Client |          & Redirection URI                  |
     |         |                                             |
     |         |<---(E)----- Access Token -------------------'
     +---------+       (w/ Optional Refresh Token)

   참고: 단계 (A), (B), (C)를 표시하는 선은 사용자 에이전트를 통과하면서 두 부분으로 나뉜다.

                     Figure 3: Authorization Code Flow
```

그림 3에서 묘사하는 흐름은 아래의 단계를 포함한다.

(A) 클라이언트는 리소스 소유자의 사용자 에이전트를 권한 부여 엔드포인트로 보내서 이 과정을 시작한다. 클라이언트는 자신의 클라이언트 식별자, 요청 범위, 지역 상태, 그리고 요청이 허가(또는 거부) 됐을 때 권한 부여 서버가 사용자 에이전트를 돌려보낼 리디렉션 URI를 포함한다.

(B) 권한 부여 서버는 사용자 에이전트를 통해 리소스 소유자를 인증하고, 리소스 소유자가 클라이언트의 접근 요청을 허가하는지 또는 거부하는지 여부를 설정한다.

(C) 리소스 소유자가 접근을 허가했다고 가정하면, 권한 부여 서버는 사전에(요청 내에서 또는 클라이언트 등록하는 동안) 제공받은 리디렉션 URI를 사용해 사용자 에이전트를 클라이언트로 리디렉트한다. 리디렉션 URI는 권한 부여 코드(authorization code)와 클라이언트가 사전에 제공한 모든 지역 상태를 포함한다.

(D) 클라이언트는 이전 단계에서 받은 권한 부여 코드(authorization code)를 포함시켜서 권한 부여 서버의 토큰 엔드포인트로 액세스 토큰을 요청한다. 요청을 생성할 때 클라이언트는 권한 부여 서버와 인증한다. 검증을 위해서 클라이언트는 권한 부여 코드를 얻기 위해 사용한 리디렉션 URI를 포함한다.

(E) 권한 부여 서버는 클라이언트를 인증하고, 권한 부여 코드(authorization code)를 확인하고, 수신된 리디렉션 URI가 과정 (C)에서 클라이언트를 리디렉션하는데 사용된 URI와 일치하는지 확인한다. 검증이 유효하다면 권한 부여 서버는 액세스 토큰과 리프레시 토큰(선택적)을 응답한다.

#### 4.1.1. Authorization Request

클라이언트는 [Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B)에 따라 "application/x-www-form-urlencoded" 형식을 사용한 권한 부여 엔드포인트 URI의 쿼리 구성요소에 다음의 매개변수를 더해서 요청을 만든다.

response_type  
필수값. 값은 "code"로 설정한다(MUST).

client_id  
필수값. 섹션 2.2에서 설명한 클라이언트 식별자.

redirect_uri  
선택값. 섹션 3.1.2에서 설명함.

scope  
선택값. 섹션 3.3에 서술된 액세스 요청의 범위.

state  
추천값. 클라이언트가 요청과 응답 사이에서 상태를 유지하는데 사용되는 불투명한 값. 권한 부여 서버는 사용자 에이전트를 클라이언트에게 리디렉션 할 때 이 값을 포함시킨다. 섹션 10.12에서 설명하는 것처럼 사이트 간 요청 위조(CSRF: cross-site request forgery)를 방지하기 위해 이 매개변수를 사용할 것을 권장한다(SHOULD).

클라이언트는 HTTP 리디렉션 응답을 사용해 생성된 URI 또는, 사용자 에이전트를 통해 이용가능한 다른 수단으로 리소스 소유자를 보낸다.

예를 들어, 클라이언트는 사용자 에이전트가 TLS를 사용해 아래와 같은 HTTP 요청을 만들도록 지시한다.

```
GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz
	&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
```

권한 부여 서버는 모든 필수 매개변수들이 존재하고 유효한지를 확인하기 위해 해당 요청을 검증한다. 요청이 유효할 경우 권한 부여 서버는 리소스 소유자를 인증하고 권한 부여 결정을 받는다(리소스 소유자에게 묻거나 다른 수단을 통해 동의를 얻음).

결정이 수립되면 권한 부여 서버는 사용자 에이전트를 HTTP 리디렉션 응답 또는, 사용자 에이전트를 통해 이용가능한 다른 수단을 사용해 클라이언트 리디렉션 URI로 보낸다.

#### 4.1.2. Authorization Response

리소스 소유자가 접근 요청을 승인했다면, 권한 부여 서버는 권한 부여 코드(authorization code)를 발급하고 아래의 매개변수들을 [Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B)에 따라 "application/x-www-form-urlencoded" 형식을 사용하는 리디렉션 URI의 쿼리 매개변수에 포함시켜서 전달한다.

code  
필수값. 권한 부여 서버가 생성한 권한 부여 코드(authorization code). 권한 부여 코드는 유출 위험을 완화하기 위해 발급된 직후에 만료되어야 한다(MUST). 권한 부여 코드의 권장 생명주기는 최대 10분이다(RECOMMENDED). 클라이언트는 권한 부여 코드를 를 두 번 이상 사용할 수 없다(MUST NOT). 권한 부여 코드가 두 번 이상 사용되었다면, 권한 부여 서버는 반드시 요청을 거부하고(MUST) 해당 권한 부여 코드를 사용해서 발급된 이전의 모든 토큰을 (가능할 때 언제든) 취소하는 것을 권장한다(SHOULD). 권한 부여 코드는 클라이언트 식별자와 리디렉션 URI에 바인딩된다.

state  
클라이언트의 권한 부여 요청에 "state" 매개변수가 존재할 경우 필수값. 클라이언트로부터 수신한 정확한(동일한) 값.

예를 들어, 권한 부여 서버는 아래의 HTTP 응답을 발송하여 사용자 에이전트를 리디렉트 한다.

```
HTTP/1.1 302 Found
Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA
	   &state=xyz
```

클라이언트는 확인되지 않은 응답 매개변수를 무시해야 한다(MUST). 권한 부여 코드의 길이는 이 명세서에서 정의하지 않는다. 클라이언트는 코드 값 길이에 대한 가정을 피해야 한다. 권한 부여 서버는 자신이 발급하는 모든 값에 대해 크기를 문서화할 것을 권장한다(SHOULD).

##### 4.1.2.1. Error Response

리디렉션 URI가 누락 또는 유효하지 않거나 일치하지 않아서 요청이 실패했을 경우, 또는 클라이언트 식별자가 누락되었거나 유효하지 않은 경우, 권한 부여 서버는 리소스 소유자에게 에러를 알릴 것을 권장하며(SHOULD), 사용자 에이전트를 잘못된 리디렉션 URI로 자동으로 리디렉트 하지 않아야 한다(MUST NOT).

리소스 소유자가 액세스 요청을 거부했거나, 리디렉션 URI의 누락 또는 유효하지 않은 경우 이외의 다른 에러로 요청이 실패했다면, 권한 부여 서버는 [Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B)에 따라 "application/x-www-form-urlencoded" 형식을 사용한 리디렉션 URI의 쿼리 구성요소에 아래의 매개변수를 추가해서 클라이언트에게 고지한다.

error  
필수값. 아래 중에서 고른 단일 아스키([USASCII](https://datatracker.ietf.org/doc/html/rfc6749#ref-USASCII)) 에러 코드.

- invalid_request: 필수 매개변수가 누락되었거나, 유효하지 않은 매개변수 값이 포함되어 있거나, 어떤 매개변수가 여러번 포함됐거나, 형식이 잘못됨.
- unauthorized_client: 클라이언트가 이 방법으로 권한 부여 코드(authorization code)를 요청하는 것을 허가받지 못함.
- access_denied: 리소스 소유자 또는 권한 부여 서버가 요청을 거부함
- unsupported_response_type: 이 방법으로 권한 부여 코드(authorization code)를 얻는 것을 권한 부여 서버가 지원하지 않음
- invalid_scope: 요청 범위가 유효하지 않거나, 알려지지 않았거나 형식이 잘못됨
- server_error: 권한 부여 서버가 예상치 못한 조건으로 인해 요청을 충족하지 못함. (500 Internal Server Error HTTP 코드는 HTTP 리디렉트를 통해 클라이언트에게 전달하지 못하기 때문에 이 에러 코드가 필요함)
- temporarily_unavailable: 일시적 과부하 또는 서버 점검으로 인해 권한 부여 서버가 현재 요청을 처리할 수 없음. (503 Service Unavailable HTTP 코드는 리디렉트를 통해 클라이언트에게 전달될 수 없기 때문에 이 에러코드가 필요함)
- "error" 매개변수의 값은 %x20-21 / %x23-5B / %x5D-7E 범위를 벗어난 문자를 포함할 수 없다(MUST).

error_description  
선택값. 발생된 에러를 클라이언트 개발자가 이해할 수 있도록 추가적인 정보를 제공하기 위한, 사람이 읽을 수 있는 아스키([USASCII](https://datatracker.ietf.org/doc/html/rfc6749#ref-USASCII)) 텍스트. %x20-21 / %x23-5B / %x5D-7E 범위를 벗어난 문자를 포함할 수 없다(MUST NOT).

error_uri  
선택값. 클라이언트 개발자가 에러에 대한 추가 정보를 얻을 수 있도록, 에러에 대한 정보를 포함하는 사람이 읽을 수 있는 웹페이지를 식별하는 URI. 이 값은 URI 참조 구문을 준수해야 하며(MUST), %x21 / %x23-5B / %x5D-7E 범위를 벗어난 문자를 사용할 수 없다(MUST NOT).

state
클라이언트의 권한 부여 요청에 "state" 값이 포함되어 있을 경우 필수값. 클라이언트로부터 수신한 정확한(동일한) 값.

예를 들어 권한 부여 서버는 아래의 HTTP 응답을 보내서 사용자 에이전트를 리디렉트 한다.

```
HTTP/1.1 302 Found
Location: https://client.example.com/cb?error=access_denied&state=xyz
```

#### 4.1.3. Access Token Request

클라이언트는 아래 매개변수들을 토큰 엔드포인트로 보내서 요청을 생성하며, 해당 매개변수들은 [Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B)에 따라 "application/x-www-form-urlencoded" 형식을 사용하고 HTTP 요청 entity-body에서 문자를 UTF-8 인코딩한다.

grant_type  
필수값. "authorization_code"로 설정해야 한다(MUST).

code  
필수값. 권한 부여 서버로부터 수신한 권한 부여 코드(authorization code)

redirect_uri  
섹션 4.1.1에 설명된 것처럼 권한 부여 요청에 "redirect_uri" 매개변수가 포함되어 있을 경우 필수값이며, 두 값은 동일해야 한다(MUST).

client_id  
섹션 3.2.1에 설명된 것처럼 클라이언트가 권한 부여와 인증하지 않을 경우 필수값.

클라이언트 유형이 기밀(confidential)이거나 클라이언트 자격증명을 발급받았다면(또는 다른 인증 요구사항을 충족했다면), 섹션 3.2.1에 서술된 것처럼 클라이언트는 권한 부여 서버와 인증해야 한다(MUST).

예를 들어, 클라이언트는 TLS를 사용해 아래의 HTTP 요청을 만든다.

```
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
```

권한 부여 서버는 반드시(MUST):

- 기밀(confidential) 클라이언트 또는 클라이언트 자격증명을 발급받은 모든 클라이언트(또는 다른 인증 자격을 갖춘 클라이이언트)에게 인증을 요구해야 한다.
- 클라이언트 인증이 포함된 경우 클라이언트를 인증한다.
- 권한 부여 코드(authorization code)가 인증 받은 기밀(confidential) 클라이언트에게 발급된 것이 맞는지를 확인하고, 클라이언트가 공개(public)인 경우 요청에 포함된 코드가 해당 "client_id"에게 발급된 것이 맞는지를 확인한다.
- 권한 부여 코드(authorization code)가 유효한지 검증한다.
- 섹션 4.1.1에 설명된 것처럼 처음의 권한 부여 요청에 "redirect_uri" 매개변수가 포함된 경우, "redirect_uri" 매개변수가 존재하는지, 그렇다면 두 값이 같은지 확인한다.

#### 4.1.4 Access Token Response

액세스 토큰 요청이 유효하고 승인되었다면, 권한 부여 서버는 섹션 5.1에 서술된 것처럼 액세스 토큰과 선택적인 리프레시 토큰을 발급한다. 클라이언트의 인증이 실패했거나 유효하지 않다면 권한 부여 서버는 섹션 5.2에 서술된 것처럼 에러를 응답한다.

성공한 응답의 예시:

```
 HTTP/1.1 200 OK
 Content-Type: application/json;charset=UTF-8
 Cache-Control: no-store
 Pragma: no-cache

 {
   "access_token":"2YotnFZFEjr1zCsicMWpAA",
   "token_type":"example",
   "expires_in":3600,
   "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
   "example_parameter":"example_value"
 }
```

### 4.2 Implicit Grant

암시적 권한 부여(implicit grant) 유형은 액세스 토큰을 얻는데 사용되며 (리프레시 토큰 발급은 지원하지 않는다) 특정한 리디렉션 URI를 운영하는 것으로 알려진 공개(public) 클라이언트에 최적화되었다. 이런 클라이언트는 일반적으로 자바스크립트 같은 스크립트 언어롤 사용해 브라우저 상에서 구현된다.

이것은 리디렉션 기반의 과정이므로 클라이언트는 리소스 소유자의 사용자 에이전트(일반적으로 웹브라우저)와 상호작용 할 수 있어야 하며 리디렉션을 통해 들어오는 권한 부여 서버의 요청을 수신할 수 있어야 한다.

권한 부여를 위한 요청과 액세스 토큰을 위한 요청이 분리된 권한 부여 코드(authorization code grant) 유형과 다르게, 클라이언트는 권한 부여 요청의 결과로 액세스 토큰을 수신한다.

암시적 권한 부여 유형은 클라이언트 인증을 포함하지 않으며 리소스 소유자의 존재와 리디렉션 URI의 등록에 의존한다. 액세스 토큰이 인코딩되어 리디렉션 URI에 포함되기 때문에, 액세스 토큰이 리소스 소유자 및 동일 디바이스에 상주하는 다른 애플리케이션에 노출될 수 있다.

```
     +----------+
     | Resource |
     |  Owner   |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier     +---------------+
     |         -+----(A)-- & Redirection URI --->|               |
     |  User-   |                                | Authorization |
     |  Agent  -|----(B)-- User authenticates -->|     Server    |
     |          |                                |               |
     |          |<---(C)--- Redirection URI ----<|               |
     |          |          with Access Token     +---------------+
     |          |            in Fragment
     |          |                                +---------------+
     |          |----(D)--- Redirection URI ---->|   Web-Hosted  |
     |          |          without Fragment      |     Client    |
     |          |                                |    Resource   |
     |     (F)  |<---(E)------- Script ---------<|               |
     |          |                                +---------------+
     +-|--------+
       |    |
      (A)  (G) Access Token
       |    |
       ^    v
     +---------+
     |         |
     |  Client |
     |         |
     +---------+

   참고: 과정 (A), (B), (C)를 표시하는 선은 사용자 에이전트를 통과하면서 두 부분으로 나뉜다.

                       Figure 4: Implicit Grant Flow
```

그림 4에서 묘사하는 흐름은 아래 과정을 포함한다.

(A) 클라이언트는 리소스 소유자의 사용자 에이전트를 권한 부여 엔드포인트로 보내서 과정을 시작한다. 클라이언트는 자신의 클라이언트 식별자, 요청 범위, 지역 상태, 접근이 승인(또는 거절) 됐을 때 권한 부여 서버가 사용자 에이전트를 되돌려보낼 리디렉션 URI를 포함한다.

(B) 권한 부여 서버는 사용자 에이전트를 통해 리소스 소유자를 인증하고 리소스 소유자가 클라이언트의 액세스 요청을 허가하는지 또는 거부하는지 여부를 설정한다.

(C) 리소스 소유자가 액세스를 승인했다고 가정하면, 권한 부여 서버는 이전에 제공받은 리디렉션 URI를 사용해 사용자 에이전트를 클라이언트로 되돌려보낸다. 리디렉션 URI는 액세스 토큰을 URI 프래그먼트에 포함한다.

(D) 사용자 에이전트는 웹 호스팅되는 클라이언트 리소스([RFC2616](https://datatracker.ietf.org/doc/html/rfc2616)에 따라 URI 프래그먼트를 포함하지 않는다)에 대한 요청을 생성하여 리디렉션 지침을 따른다. 사용자 에이전트는 프래그먼트 정보를 로컬에서 유지한다.

(E) 웹 호스팅되는 클라이언트 리소스는 사용자 에이전트가 유지하는 프래그먼트를 포함해 전체 리디렉션 URI의 접근할 수 있는 웹 페이지를 리턴하고(일반적으로 스크립트가 내장된 HTML 문서), 프래그먼트에 포함된 액세스 토큰과 다른 매개변수들을 추출한다.

(F) 사용자 에이전트는 웹 호스팅되는 클라이언트 자원이 제공한 스크립트를 로컬에서 실행해서 액세스 토큰을 추출한다.

(G) 사용자 에이전트가 액세스 토큰을 클라이언트에게 전달한다.

암시적 권한 부여(implicit grant)를 사용하는 배경에 대해 섹션 1.3.2와 섹션 9를 참조하시오. 암시적 권한 부여(implicit grant)를 사용할 때의 중요한 보안 고려사항에 대해 섹션 10.3과 10.6을 참조하시오.

#### 4.2.1. Authorization Request

클라이언트는 [Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B)에 따라 "application/x-www-form-urlencoded" 형식을 사용하는 권한 엔드포인트 URI의 쿼리 구성요소에 아래의 매개변수를 추가해서 요청 URI를 생성한다.

response_type  
필수값. 값은 반드시 "token"이다(MUST).

client_id  
필수값. 섹션 2.2에서 설명한 클라이언트 식별자.

redirect_uri  
선택값. 섹션 3.1.2에서 서술.

scope  
선택값. 섹션 3.3에 서술된 액세스 요청의 범위.

state  
추천값. 클라이언트가 요청과 응답 사이에서 상태를 유지하는데 사용되는 불투명한 값. 권한 부여 서버는 사용자 에이전트를 리디렉션해서 클라이언트에게 되돌려 보낼 때 이 값을 포함해준다. 이 매개변수를 섹션 10.12에서 설명하는 것처럼 사이트 간 요청 위조(CSRF: cross-site request forgery)를 방지하는데 사용할 것을 권장한다(SHOULD).

클라이언트는 HTTP 리디렉션 응답을 사용하거나, 또는 사용자 에이전트를 통해 이용 가능한 다른 수단을 사용해 리소스 소유자를 생성된 URI로 보낸다.

예를 들어 클라이언트는 사용자 에이전트가 TLS를 사용해서 아래의 HTTP 요청을 만들도록 한다.

```
GET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz
	&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
```

권한 부여 서버는 모든 필수 매개변수들이 존재하고 유효한지를 확인하기 위해 요청을 검증한다. 권한 부여 서버는 섹션 3.1.2에 설명한 것처럼 액세스 토큰을 리디렉션할 URI가 클라이언트가 등록한 리디렉션 URI와 일치하는지 확인해야 한다(MUST).

요청이 유효하다면, 권한 부여 서버는 리소스 소유자를 인증하고 권한 부여 결정을 설정한다(리소스 소유자에게 묻거나 다른 수단을 사용해 동의를 얻음).

결정이 수립되면 권한 부여 서버는 HTTP 리디렉션 응답 또는, 사용자 에이전트를 통해 이용가능한 다른 수단을 사용해 사용자 에이전트를 클라이언트 리디렉션 URI로 보낸다.

#### 4.2.2. Access token Response

리소스 소유자가 액세스 요청을 승인했다면, 권한 부여 서버는 액세스 토큰을 발급하고 [Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B)에 따라 "appication/x-www-form-urlencoded" 형식을 사용한 리디렉션 URI의 프래그먼트 구성요소에 아래 매개변수들을 추가하여 해당 액세스 토큰을 클라이언트에게 전달한다.

access_token  
필수값. 권한 부여 서버가 발급한 액세스 토큰

token_type  
필수값. 섹션 7.1에서 설명하는 발급된 토큰의 유형. 대소문자를 구분하지 않는다.

expires_in  
추천값. 액세스 토큰의 생명주기. 예를 들어 "3600" 값은 응답이 생성된 시각으로부터 한 시간 후에 액세스 토큰이 만료될 것을 나타낸다. 생략된 경우, 권한 부여 서버는 기본값을 문서화하거나 다른 수단을 통해 만료 시각을 제공할 것을 권장한다(SHOULD).

scope  
클라이언가 요청한 범위와 동일하다면 선택값, 그렇지 않다면 필수값. 섹션 3.3에서 설명한 액세스 토큰의 범위.

state
클라이언트의 권한 부여 요청에 "state" 매개변수가 존재한다면 필수값. 클라이언트로부터 수신한 정확한(동일한) 값.

권한 부여 서버는 리프레시 토큰을 발급해서는 안 된다(MUST NOT).

예를 들어 권한 부여 서버는 아래의 HTTP 응답을 발송하여 사용자 에이전트를 리디렉트 한다.

```
HTTP/1.1 302 Found
Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA
	   &state=xyz&token_type=example&expires_in=3600
```

개발자는 일부 사용자 에이전트가 HTTP "Location" 응답 헤더 필드에 프래그먼트가 포함되는 것을 지원하지 않는다는 점을 주의해야 한다. 이런 클라이언트는 3xx 리디렉션 응답이 아닌 다른 리디렉션 방법이 필요하다. 예를 들면 리디렉션 URI로 연결되는 "계속" 버튼을 포함하는 HTML 페이지를 리턴하는 것이다.

클라이언트는 알려지지 않은 매개변수를 무시해야 한다(MUST). 액세스 토큰 문자열의 길이는 이 명세서에서 정의하지 않는다. 클라이언트는 값의 크기에 대해 가정을 피해야 한다. 권한 부여 서버는 자신이 발급하는 모든 값에 대해 크기를 문서화 할 것을 권장한다(SHOULD).

##### 4.2.2.1 Error Response

리디렉션 URI의 누락, 유효하지 않음, 불일치로 인해 요청이 실패했거나, 또는 클라이언트 식별자가 누락되거나 유효하지 않다면 권한 부여 서버는 리소스 소유자에게 에러에 대해 알릴 것을 권장하며(SHOULD), 사용자 에이전트를 잘못된 리디렉션 URI로 자동으로 리디렉션 하지 않아야 한다(MUST NOT).

리소스 소유자가 액세스 요청을 거부했거나, 리디렉션 URI의 누락 또는 유효하지 않은 경우 이외의 다른 에러로 요청이 실패했다면, 권한 부여 서버는 [Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B)에 따라 "application/x-www-form-urlencoded" 형식을 사용한 리디렉션 URI의 프래그먼트 구성요소에 아래의 매개변수를 추가하여 클라이언트에게 고지한다.

error  
필수값. 아래의 단일 아스키([USASCII](https://datatracker.ietf.org/doc/html/rfc6749#ref-USASCII)) 에러 코드.

- invalid_request: 요청에서 필수 매개변수가 빠졌거나, 잘못된 매개변수 값을 포함했거나, 어떤 매개변수가 여러번 포함됐거나, 형식이 잘못됨.
- unauthorized_client: 클라이언트가 이 방법을 사용한 액세스 토큰을 요청하는 것을 허가받지 않음.
- access_denied: 리소스 소유자 또는 권한 부여 서버가 요청을 거부함.
- unsupported_response_type: 이 방법을 사용해 액세스 토큰을 얻는 것을 권한 부여 서버가 지원하지 않음.
- invalid_scope: 요청 범위가 유효하지 않거나, 알려지지 않았거나 형식이 잘못됨.
- server_error: 권한 부여 서버가 예측하지 못한 조건으로 인해 요청을 충족하지 못하게 되었을 때. (HTTP 상태 코드 500 Internal Server Error가 HTTP 리디렉트를 통해 클라이언트에게 전달될 수 없기 때문에 이 에러 코드가 필요함)
- temporarily_unavailable: 권한 부여 서버가 일시적인 과부하나 서버 점검으로 인해 현재 요청을 처리할 수 없음. (HTTP 상태 코드 503 Internal Server Error가 HTTP 리디렉트를 통해 클라이언트에게 전달될 수 없기 때문에 이 에러 코드가 필요함)
- "error" 매개변수의 값은 %x20-21 / %x23-5B / %x5D-7E 범위를 벗어나는 문자를 사용할 수 없다(MUST NOT).

error_description  
선택값. 클라이언트 개발자가 발생한 에러를 이해할 수 있도록 추가적인 정보를 제공하는, 사람이 읽을 수 있는 아스키 문서([USASCII](https://datatracker.ietf.org/doc/html/rfc6749#ref-USASCII)).
"error_description"의 값은 %x20-21 / %x23-5B / %x5D-7E 범위를 벗어나는 문자를 사용할 수 없다(MUST NOT).

error_uri  
선택값. 발생된 에러를 클라이언트 개발자가 이해할 수 있도록 하는 추가 정보를 담은, 사람이 읽을 수 있는 웹페이지를 명시한 URI.
"error_uri" 값은 URI 참조 구문을 준수해야 하며(MUST), %x20-21 / %x23-5B / %x5D-7E 범위를 벗어난 문자를 포함할 수 없다(MUST NOT).

state  
클라이언트 권한 부여 요청에 "state" 매개변수가 포함되어 있다면 필수값. 클라이언트로부터 수신한 정확한(동일한) 값.

예를 들어 권한 부여 서버는 아래의 HTTP 응답을 보내서 사용자 에이전트를 리디렉트 한다.

```
HTTP/1.1 302 Found
Location: https://client.example.com/cb#error=access_denied&state=xyz
```

### 4.3. Resource Owner Password Credentials Grant

리소스 소유자 비밀번호 자격증명(resource owner password credentials) 권한 부여 유형(grant type)은 디바이스의 운영체제나 높은 특권을 가진 애플리케이션처럼, 리소스 소유자가 클라이언트와 신뢰 관계를 가진 경우에 적합한 권한 부여 유형이다. 권한 부여 서버는 이 권한 부여 유형을 활성화 할 때 매우 주의를 기울여야 하며 다른 방법이 가능하지 않을 때만 허용해야 한다.

이 권한 부여 유형(grant type)은 클라이언트가 리소스 소유자의 자격증명(일반적으로 대화형 양식을 사용하는 얻은 사용자 이름과 비밀번호)을 얻을 수 있을 때 적합한 방법이다. 이 유형은 HTTP 기본 인증 또는 다이제스트 인증 같은 직접 인증체계를 사용하는 기존의 클라이언트에서 저장된 자격증명을 액세스 토큰으로 변환하여 OAuth로 마이그레이션 하는데도 사용된다.

```
     +----------+
     | Resource |
     |  Owner   |
     |          |
     +----------+
          v
          |    Resource Owner
         (A) Password Credentials
          |
          v
     +---------+                                  +---------------+
     |         |>--(B)---- Resource Owner ------->|               |
     |         |         Password Credentials     | Authorization |
     | Client  |                                  |     Server    |
     |         |<--(C)---- Access Token ---------<|               |
     |         |    (w/ Optional Refresh Token)   |               |
     +---------+                                  +---------------+

            Figure 5: Resource Owner Password Credentials Flow
```

그림 5에서 묘사된 흐름은 아래 과정을 포함한다.

(A) 리소스 소유자는 클라이언트에게 자신의 사용자 이름과 비밀번호를 제공한다.

(B) 클라이언트는 리소스 소유자에게 받은 자격 증명을 포함해 권한 부여 서버의 토큰 엔드포인트로 액세스 토큰을 요청한다. 요청을 생성할 때 클라이언트는 권한 부여 서버와 인증한다.

(C) 권한 부여 서버는 클라이언트를 인증하고 리소스 소유자의 자격증명을 검증해서, 유효하다면 액세스 토큰을 발급한다.

#### 4.3.1. Authorization Request and Response

클라이언트가 리소스 소유자의 자격증명을 얻는 방법은 이 명세서의 범위를 벗어난다. 클라이언트는 액세스 토큰을 얻은 즉시 자격증명을 폐기해야 한다(MUST).

#### 4.3.2. Access Token Request

HTTP 요청 entity-body에서 UTF-8 인코딩 문자를 사용하며, [Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B)에 따라 "application/x-www-form-urlencoded" 형식을 사용하는 쿼리 구성요소에 아래의 매개변수를 더해서 클라이언트는 토큰 엔드포인트로 요청을 생성한다.

grant_type  
필수값. 값은 "password"로 설정해야 한다(MUST).

username  
필수값. 리소스 소유자의 사용자 이름.

password  
필수값. 리소스 소유자의 비밀번호.

scope  
선택값. 섹션 3.3에 서술된 액세스 요청의 범위.

클라이언트 유형이 기밀(confidential)이거나, 클라이언트에 클라이언트 자격증명이 발급된 경우 (또는 다른 인증 요구사항이 할당된 경우) 클라이언트는 섹션 3.2.1에 서술된 것처럼 권한 부여 서버와 인증해야 한다(MUST).

예를 들어 클라이언트는 전송 계층 보안을 사용해 아래의 HTTP 요청을 생성한다.

```
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=password&username=johndoe&password=A3ddj3w
```

인증 서버는 반드시(MUST):

- 기밀(confidential) 클라이언트나 클라이언트 자격증명을 발급받은 모든 클라이언트 (또는 다른 인증 요구사항을 따르는)에게 클라이언트 인증을 요구한다.
- 클라이언트 인증이 포함되어 있다면, 클라이언트를 인증한다.
- 기존 비밀번호 검증 알고리즘을 사용해 리소스 소유자의 비밀번호 자격증명을 검증한다.

이 방식의 액세스 토큰 요청은 리소스 소유자의 비밀번호를 활용하기 때문에, 권한 부여 서버는 엔드포인트를 무차별 대입 공격으로부터 보호해야 한다(MUST). (예: 속도 제한 사용 또는 경고 생성)

#### 4.3.3. Access Token Response

섹션 5.1에 서술된 것처럼, 액세스 토큰 요청이 유효하고 승인된 경우 권한 부여 서버는 액세스 토큰과 선택적인 리프레시 토큰을 발급한다. 해당 요청이 클라이언트 인증에 실패하거나 또는 유효하지 않은 경우, 권한 부여 서버는 섹션 5.2에 서술된 것처럼 에러 응답을 반환한다.

성공적인 응답의 예시:

```
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
	"access_token":"2YotnFZFEjr1zCsicMWpAA",
	"token_type":"example",
	"expires_in":3600,
	"refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
	"example_parameter":"example_value"
}
```

### 4.4. Client Credentials Grant

클라이언트가 자신의 제어 하에 있는 보호 리소스에 대한 액세스 요청을 하거나, 권한 부여 서버와 사전에 합의된 리소스 소유자의 보호 리소스에 대한 액세스 요청을 할 때는 자신의 클라이언트 자격증명만 가지고 액세스 토큰을 요청할 수 있다. (권한 부여 서버와 사전 합의를 하는 방법은 이 명세서의 범위를 벗어난다)

클라이언트 자격증명(client credentials) 권한 부여 유형(grant type)은 기밀(confidential) 클라이언트에서만 사용할 수 있다(MUST).

```
     +---------+                                  +---------------+
     |         |                                  |               |
     |         |>--(A)- Client Authentication --->| Authorization |
     | Client  |                                  |     Server    |
     |         |<--(B)---- Access Token ---------<|               |
     |         |                                  |               |
     +---------+                                  +---------------+

                     Figure 6: Client Credentials Flow
```

그림 6에 묘사된 흐름은 아래의 과정을 포함한다.

(A) 클라이언트가 권한 부여 서버에 인증하고 토큰 엔드포인트로부터 액세스 토큰을 요청한다.

(B) 권한 부여 서버는 클라이언트를 인증하고, 유효하다면 액세스 토큰을 발급한다.

#### 4.4.1. Authorization Request and Response

해당 클라이언트 인증이 권한 부여 허가(authorization grant)로써 사용되기 때문에 추가적인 권한 부여 요청은 필요하지 않다.

#### 4.4.2. Access Token Request

[Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B)에 따라 "application/x-www-urlencoded" 형식을 사용하고 HTTP 요청 entity-body가 UTF-8 문자로 인코딩 된 매개변수에 아래 매개변수를 추가하여 클라이언트는 토큰 엔드포인트로 요청을 생성한다.

grant_type  
필수값. 값은 "client_credentials"로 설정해야 한다(MUST).

scope  
선택값. 섹션 3.3에 서술된 액세스 요청의 범위.

클라이언트는 섹션 3.2.1에 서술된 것처럼 권한 부여 서버와 인증해야 한다(MUST).

예를 들어, 클라이언트는 전송 계층 보안을 사용해 아래의 HTTP 요청을 생성한다.

```
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
```

권한 부여 서버는 반드시 클라이언트를 인증한다(MUST).

#### 4.4.3. Access Token Response

섹션 5.1의 설명처럼, 액세스 토큰 요청이 유효하고 승인된 경우 권한 부여 서버는 액세스 토큰을 발급한다. 리프레시 토큰은 포함하지 않을 것을 권장한다(SHOULD NOT). 섹션 5.2에서 설명하는 것처럼, 요청이 클라이언트 인증을 실패했거나 요청이 유효하지 않은 경우 권한 부여 서버는 에러 응답을 반환한다.

성공 응답의 예시:

```
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
"access_token":"2YotnFZFEjr1zCsicMWpAA",
"token_type":"example",
"expires_in":3600,
"example_parameter":"example_value"
}
```

### 4.5. Extension Grants

절대 URI(권한 부여 서버에서 정의)를 사용한 권한 부여 유형(grant type)을 토큰 엔드포인트의 "grant_type" 매개변수 값으로 지정하고, 필요한 모든 추가적인 매개변수를 더하는 방법으로 클라이언트는 확장 권한 부여 유형(grant type)을 사용한다.

예를 들어 [OAuth-SAML2](https://datatracker.ietf.org/doc/html/rfc6749#ref-OAuth-SAML2)에 정의된 보안 주장 마크업 언어(SAML: Security Assertion Markup Language) 2.0의 "assertion grant type"을 사용해 액세스 토큰을 요청하려면, 클라이언트는 TLS를 사용해서 아래의 HTTP 요청을 생성한다.

```
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-
bearer&assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ9IjIwMTEtMDU
[...omitted for brevity...]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-
```

섹션 5.1에 설명된 대로 액세스 토큰이 유효하고 승인된 경우, 권한 부여 서버는 액세스 토큰과 선택적인 리프레시 토큰을 발급한다. 섹션 5.2에 설명된 것처럼, 해당 요청이 클라이언트 인증을 실패했거나 또는 요청이 유효하지 않은 경우 권한 부여 서버는 에러 응답을 반환한다.

## 5. Issuing an Access Token

섹션 5.1에 설명된 대로 액세스 토큰이 유효하고 승인된 경우, 권한 부여 서버는 액세스 토큰과 선택적인 리프레시 토큰을 발급한다. 섹션 5.2에 설명된 것처럼, 해당 요청이 클라이언트 인증을 실패했거나 또는 요청이 유효하지 않은 경우 권한 부여 서버는 에러 응답을 반환한다.

### 5.1. Successful Response

권한 부여 서버는 액세스 토큰과 선택적인 리프레시 토큰을 발급하고, HTTP 응답의 entity-body에 아래의 매개변수들을 추가하고 200 (OK) 상태 코드를 포함하여 응답을 생성한다.

access_token  
필수값. 권한 부여 서버가 발급한 액세스 토큰

token_type  
필수값. 섹션 7.1에 설명된 토큰의 유형. 대소문자를 구분하지 않는다.

expires_in  
추천값. 액세스 토큰의 생명주기. 예를 들어 "3600" 값은 응답이 생성된 시각으로부터 한 시간 후에 액세스 토큰이 만료될 것을 나타낸다. 생략된 경우 권한 부여 서버는 다른 수단을 통해 만료 시각을 제공하거나 기본값을 문서화할 것을 권장한다(SHOULD).

refresh_token  
선택값. 섹션 6에 설명된 것처럼 동일한 권한 부여 승인(authorization grant)을 사용해 새로운 액세스 토큰을 얻기 위해 사용할 수 있는 리프레시 토큰.

scope  
클라이언트가 요청한 범위와 동일하다면 선택값, 그렇지 않다면 필수값. 섹션 3.3에 설명된 액세스 토큰의 범위.

매개변수는 [RFC4627](https://datatracker.ietf.org/doc/html/rfc4627)에 정의된 "application/json" 미디어 유형을 사용해서 HTTP 응답의 entity-body에 포함된다. 매개변수들은 자바스크립트 객체 표기법(JSON: JavaScript Object Notation) 구조에서 최상위 구조 레벨에 각각의 매개변수를 추가하여 직렬화 한다. 매개변수 이름과 문자열 값은 JSON 문자열로 포함된다. 숫자 값들은 JSON 숫자로 포함된다. 매개변수의 순서는 중요하지 않으며 달라질 수 있다.

권한 부여 서버는 토큰, 자격증명 또는 민감한 정보를 포함하는 모든 응답에서, HTTP "Cache-Control" 응답 헤더 필드([RFC2616](https://datatracker.ietf.org/doc/html/rfc2616))에 "no-store" 값을, "Pragma" 응답 헤더 필드([RFC2616](https://datatracker.ietf.org/doc/html/rfc2616))에는 "no-cache" 값을 포함해야 한다(MUST).

예시:

```
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
"access_token":"2YotnFZFEjr1zCsicMWpAA",
"token_type":"example",
"expires_in":3600,
"refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
"example_parameter":"example_value"
}
```

클라이언트는 응답에서 인식할 수 없는 값 이름은 무시해야 한다(MUST). 토큰 및 권한 부여 서버로부터 받는 다른 값들의 크기는 정의하지 않는다. 클라이언트는 값의 크기에 대해 가정을 피해야 한다. 권한 부여 서버는 자신이 발급하는 모든 값의 크기를 문서화할 것을 권장한다(SHOULD).

### 5.2. Error Response

권한 부여 서버는 HTTP 400 (Bad Request) 상태 코드를 응답하고 아래 매개변수를 응답에 포함한다.

error  
필수값. 아래의 단일 아스키([USASCII](https://datatracker.ietf.org/doc/html/rfc6749#ref-USASCII)) 에러 코드.

- invalid_request: 요청이 필수 매개변수를 누락하거나, 지원하지 않는 매개변수 값권한 부여 유형(grant type) 이외에)을 포함하거나, 다수의 자격증명을 포함하거나, 클라이언트 인증을 위해 둘 이상의 메커니즘을 활용하거나, 형식이 잘못됨
- invalid_client: 클라이언트 인증이 실패함(예: 알려지지 않은 클라이언트, 클라이언트 인증이 포함되지 않음, 지원되지 않는 인증 방법). 권한 부여 서버는 지원하는 HTTP 인증 체계를 나타내기 위해 HTTP 401 (Unauthorized) 상태 코드를 응답할 수 있다(MAY). 클라이언트가 "Authorization" 요청 헤더를 통해 인증을 시도하는 경우, 권한 부여 서버는 HTTP 401 (Unauthorized) 상태 코드로 응답해야 하며(MUST) 클라이언트가 사용한 인증 체계와 일치하는 "WWW-Authenticate" 응답 헤더 필드를 포함한다.
- invalid_grant: 제공된 권한 부여 유형(authorization grant) (예: 권한 부여 토큰 또는 리소스 소유자의 자격증명) 또는 리프레시 토큰이 유효하지 않거나, 만료됐거나, 취소되거나, 또는 권한 부여 요청에서 사용된 리디렉션 URI가 일치하지 않거나, 다른 클라이언트에게 발급된 것인 경우.
- unauthorized_client: 인증된 클라이언트가 이 권한 부여 유형을(authorization grant type) 사용하는 것이 허가되지 않음.
- unsupported_grant_type: 권한 부여 서버가 지원하지 않는 권한 부여 유형(authorization grant type).
- invalid_scope: 요청 범위가 유효하지 않거나, 알려지지 않았거나, 형식이 잘못됐거나 리소스 소유자가 허가한 범위를 초과함.
- "error" 매개변수의 값은 %x20-21 / %x23-5B / %x5D-7E 범위를 벗어난 문자를 포함 할 수 없다(MUST NOT).

error_description  
선택값. 클라이언트 개발자가 발생한 에러를 이해할 수 있도록 추가적인 정보를 제공하기 위한, 사람이 읽을 수 있는 아스키([USASCII](https://datatracker.ietf.org/doc/html/rfc6749#ref-USASCII)) 텍스트. %x20-21 / %x23-5B / %x5D-7E 범위를 벗어난 문자를 포함할 수 없다(MUST NOT).

error_uri  
선택값. 클라이언트 개발자가 에러에 대한 추가 정보를 얻을 수 있도록, 사람이 읽을 수 있는 에러에 대한 웹페이지를 식별하는 URI. 이 값은 URI 참조 구문을 준수하며 %x21 / %x23-5B / %x5D-7E 범위를 벗어난 문자를 사용할 수 없다(MUST NOT).

매개변수들은 [RFC4627](https://datatracker.ietf.org/doc/html/rfc4627)에 정의된 "application/json" 미디어 유형을 사용한 HTTP 응답의 entity-body에 포함된다. 매개변수들은 자바스크립트 객체 표기법(JSON: JavaScript Object Notation) 구조에서 최상위 구조 레벨에 각각의 매개변수를 추가하여 직렬화 된다. 매개변수 이름과 문자열 값은 JSON 문자열로 포함된다. 숫자 값들은 JSON 숫자로 포함된다. 매개변수의 순서는 중요하지 않으며 달라질 수 있다.

예시:

```
HTTP/1.1 400 Bad Request
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "error":"invalid_request"
}
```

## 6. Refreshing an Access Token

권한 부여 서버가 클라이언트에게 리프레시 토큰을 발급했다면, [Appendix B](https://datatracker.ietf.org/doc/html/rfc6749#appendix-B)에 따라 "application/x-www-form-urlencoded" 형식(HTTP 요청 entity-body에 UTF-8 문자 인코딩을 사용)을 사용한 아래의 매개변수들을 더해서 토큰 엔드포인로 새로 고침 요청을 생성한다.

grant_type  
필수값. 반드시 "refresh_token"으로 설정한다(MUST).

refresh_token  
필수값. 클라이언트에게 발급되는 리프레시 토큰.

scope  
선택값. 섹션 3.3에 서술된 액세스 요청. 요청 범위는 리소스 소유자가 기존에 허가하지 않은 범위를 포함 할 수 없으며(MUST NOT), 생략된 경우 리소스 소유자가 허가한 기존 범위와 동일한 것으로 취급된다.

리프레시 토큰은 추가적인 액세스 토큰을 요청할 때 사용되는 일반적으로 오래 지속되는 자격증명이기 때문에, 리프레시 토큰은 발급된 클라이언트와 바인딩 되어야 한다. 섹션 3.2.1의 설명처럼, 클라이언트 유형이 기밀(confidential)이거나 클라이언트가 클라이언트 자격증명을 발급받은 경우(또는 인증 요구사항이 할당된 경우), 클라이언트는 권한 부여 서버와 인증해야 한다(MUST).

예를 들어, 클라이언트는 전송 계층 보안을 사용해 아래의 HTTP 요청을 생성한다.

```
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
```

권한 부여 서버는 반드시(MUST):

- 기밀(confidential) 클라이언트 또는 클라이언트 자격증명을 발급받은 클라이언트 (또는 다른 인증 요구사항을 가진) 클라이언트에게 인증을 요구해야 한다.
- 클라이언트 인증을 포함하는 경우는 클라이언트를 인증하고, 해당 리프레시 토큰이 인증된 클라이언트에게 발급된 것이 맞는지 확인해야 한다.
- 리프레시 토큰을 검증해야 한다.

유효하고 승인된 경우, 권한 부여 서버는 섹션 5.1에 서술된 것처럼 액세스 토큰을 발급한다. 요청 검증이 실패했거나 요청이 유효하지 않은 경우 권한 부여 서버는 섹션 5.2에 서술된 것처럼 에러 응답을 반환한다.

권한 부여 서버는 새로운 리프레시 토큰을 발행할 수 있으며(MAY), 그 경우 클라이언트는 오래된 기존 리프레시 토큰을 폐기하고 새로운 리프레시 토큰으로 교체해야 한다(MUST). 권한 부여 서버는 클라이언트에 새 리프레시 토큰을 발급한 후 오래된 리프레시 토큰을 취소할 수 있다(MAY). 새 리프레시 토큰이 발급된 경우, 해당 리프레시 토큰의 범위는 클라이언트의 요청에 포함된 리프레시 토큰의 범위와 일치해야 한다.

## 7. Accessing Protected Resources

클라이언트는 리소스 서버에 액세스 토큰을 제시하여 보호 리소스에 접근한다. 리소스 서버는 액세스 토큰을 검증해야 하고 토큰이 만료되지 않았는지, 토큰의 범위가 요청한 리소스를 커버하는지 확인해야 한다(MUST). 리소스 서버가 액세스 토큰(및 에러 응답)을 검증하는데 사용하는 방법은 이 명세서의 범위를 벗어나지만 일반적으로 리소스 서버와 권한 부여 서버 사이의 상호작용 내지는 조정을 수반한다.

클라이언트가 리소스 서버와 인증하기 위해 액세스 토큰을 활용하는 방법은 권한 부여 서버가 발행한 액세스 토큰의 유형에 따라 다르다. 일반적으로 [RFC6750](https://datatracker.ietf.org/doc/html/rfc6750) 같은 액세스 토큰 유형 사용 명세서에서 정의하는 인증 체계와 함께 HTTP "Authorization" 요청 헤더 필드([RFC2617](https://datatracker.ietf.org/doc/html/rfc2617))를 사용하는 것이 이 방법에 포함된다.

### 7.1. Access Token Types

액세스 토큰의 유형은 유형별 속성에 따라 해당 토큰을 활용해 보호 리소스에 대한 접근 요청을 성공적으로 생성하는데 필요한 정보를 제공한다. 클라이언트는 액세스 토큰의 유형을 이해하지 못한 경우 사용해서는 안 된다(MUST NOT).

예를 들어 [RFC6750](https://datatracker.ietf.org/doc/html/rfc6750)에 정의된 "bearer" 토큰 유형은 액세스 토큰 문자열을 요청에 포함하는 간단한 방법으로 활용할 수 있다.

```
GET /resource/1 HTTP/1.1
Host: example.com
Authorization: Bearer mF_9.B5f-4.1JqM
```

반면 [OAuth-HTTP-MAC](https://datatracker.ietf.org/doc/html/rfc6749#ref-OAuth-HTTP-MAC)에 정의된 "mac" 토큰 유형은 메시지 인증 코드(MAC: Message Authentication Code) 키를 HTTP 요청의 특정 구성 요소를 서명하는데 사용되는 액세스 토큰과 함께 발급하여 활용된다.

```
GET /resource/1 HTTP/1.1
Host: example.com
Authorization: MAC id="h480djs93hd8",
					nonce="274312:dj83hs9s",
					mac="kDZvddkndxvhGRXZhvuDjEWhGeE="
```

위의 예시는 설명 목적으로만 제공된다. 개발자는 사용하기 전에 [RFC6750](https://datatracker.ietf.org/doc/html/rfc6750)와 [OAuth-HTTP-MAC](https://datatracker.ietf.org/doc/html/rfc6749#ref-OAuth-HTTP-MAC) 명세를 참조하는 것이 좋다.

각 액세스 토큰 유형의 정의는 추가 속성을 지정한다. 그런 추가 속성이 존재한다면 클라이언트에 "access_token" 응답 매개변수로 전달된다. 또한 액세스 토큰의 유형은 보호 리소스에 접근 요청을 생성할 때 액세스 토큰을 포함하기 위해 사용되는 HTTP 인증 방법도 정의한다.

### 7.2. Error Response

리소스 액세스 요청이 실패했다면, 리소스 서버는 클라이언트에게 에러에 대해 알릴 것을 권장한다(SHOULD). 해당 에러 응답의 세부사항은 이 명세서의 범위를 벗어나지만, 이 문서는 섹션 11.4에서 OAuth 토큰 인증 체계에서 공유할 에러 값들에 대한 공통 레지스트리를 설정한다.

주로 OAuth 토큰 인증을 위해 설계된 새로운 인증 체계는 클라이언트에게 에러 상태 코드를 전달하는 메커니즘을 정의할 것을 권장하며(SHOULD), 허용되는 에러 값은 이 명세서가 설정한 에러 레지스트리에 등록된다.

그러한 체계는 유효한 에러 코드의 집합을 등록된 값의 부분 집합으로 제한할 수 있다(MAY). 명명된 매개변수 이름을 사용해 에러 코드를 반환하는 경우, 해당 매개변수 이름은 "error"로 할 것을 권장한다(SHOULD).

OAuth 토큰 인증에서 사용할 수 있지만 주로 해당 목적으로 설계되지 않은 다른 체계는 동일한 방식으로 에러 값을 레지스트리에 바인딩할 수 있다(MAY).

새로운 인증 체계는, 에러 정보를 반환하는 "error_description"과 "error_uri" 매개변수의 사용법을 이 명세서에서 사용하는 것과 유사한 방법으로 지정할지를 선택할 수 있다(MAY).

## 8. Extensibility

### 8.1. Defining Access Token Types

액세스 토큰의 유형은 두 가지 방법 중 하나로 정의할 수 있다. 액세스 토큰 타입 레지스트리(Access Token Type registry)에 등록하거나(섹션 11.1의 과정을 따름), 고유한 절대 URI를 자신의 이름으로 사용한다.

URI 이름을 활용하는 유형은 일반적으로 적용되지 않는 공급업체별 구현으로 제한하고, 그것을 사용하는 리소스 서버의 구현 세부사항으로 특정할 것을 권장한다(SHOULD).

다른 모든 유형은 반드시 등록되어야 한다(MUST). 유형 이름은 반드시 ABNF를 준수해야 한다(MUST). 유형 정의가 새로운 HTTP 인증 체계를 포함한다면, 유형 이름은 HTTP 인증 체계의 이름([[RFC2617](https://datatracker.ietf.org/doc/html/rfc2617)]에 정의됨)과 동일하게 하도록 권장한다(SHOULD). 토큰 유형 "example"은 예시를 위한 용도로 예약되어 있다.

```
type-name  = 1*name-char
name-char  = "-" / "." / "_" / DIGIT / ALPHA
```

### 8.2. Defining New Endpoint Parameters

인증 엔드포인트 또는 토큰 엔드포인트에서 사용되는 새로운 요청 또는 응답 매개변수는 섹션 11.2의 절차에 따라 OAuth 매개변수 레지스트리에 정의되고 등록된다.

매개변수 이름은 ABNF를 준수해야 하며 매개변수 값 구문은 잘 정의되어 있어야 한다(MUST). (예: ABNF를 사용하거나 기존 매개변수 구문을 참고)

```
param-name  = 1*name-char
name-char   = "-" / "." / "_" / DIGIT / ALPHA
```

일반적으로 적용되지 않으며 사용하는 권한 부여 서버의 구현 세부사항에 특정된, 등록되지 않은 공급업체별 매개변수 확장은 다른 등록 값들과 충돌할 가능성이 낮은 공급업체별 접두사를 활용할 것을 권장한다(SHOULD). (예: 'companyname\_'으로 시작)

### 8.3. Defining New Authorization Grant Types

새로운 권한 부여 유형(authorization grant type)은 "grant_type" 매개변수와 함께 사용할 고유한 절대 URI를 할당하여 정의할 수 있다. 권한 부여 유형 확장에 추가적인 토큰 엔드포인트 매개변수가 필요한 경우 섹션 11.2에 서술된 것처럼 반드시 OAuth 매개변수 레지스트리에 등록되어야 한다(MUST).

### 8.4. Defining New Authorization Endpoint Response Types

권한 부여 엔드포인트와 함께 사용할 새로운 응답 유형은 섹션 11.3의 과정을 따라 "권한 부여 엔드포인트 응답 유형" 레지스트리에 정의되고 등록된다. 응답 유형 이름은 ABNF 응답의 유형을 준수해야 한다(MUST).

```
response-type  = response-name *( SP response-name )
response-name  = 1*response-char
response-char  = "_" / DIGIT / ALPHA
```

응답 유형이 하나 이상의 공백 문자(%x20)을 포함하고 있다면, 공백으로 구분된 값의 목록으로 비교되며 값의 순서는 중요하지 않다. 동일한 값 집합의 다른 모든 배열을 포함하는 하나의 값 순서만 등록할 수 있다.

예를 들어 응답 유형 "token code"는 이 명세서에서 정의하지 않는다. 그러나 확장은 "token code" 응답 유형을 정의하고 등록할 수 있다. 등록된 다음에는 "code token" 같은 동일한 조합은 등록될 수 없지만, 두 값 모두 동일한 응답 유형을 나타내는데 사용될 수 있다.

### 8.5. Defining Additional Error Codes

프로토콜 확장(예: 액세스 토큰 유형, 매개변수 확장 또는 권한 부여 유형 확장)이 권한 부여 코드 유형의 에러 응답(섹션 4.2.2.1)과 사용되는 추가적인 에러 코드를 필요로 하는 경우, 암시적 권한 부여(implicit grant) 에러 응답(섹션 4.2.2.1), 토큰 에러 응답(섹션 5.2) 또는 리소스 액세스 에러 응답(섹션 7.2) 등의 에러 코드가 정의될 수 있다(MAY).

등록된 액세스 토큰 유형, 등록된 엔드포인트 매개변수, 확장 권한 부여 유형과 함께 사용되는 확장의 경우, 반드시 확장 에러 코드가 (섹션 11.4의 과정을 따라) 등록되어야 한다(MUST). 등록되지 않은 확장과 사용되는 에러 코드도 등록할 수 있다(MAY).

에러 코드는 ABNF를 준수해야 하며(MUST), 가능한 경우 식별 이름으로 접두사를 붙일 것을 권장한다(SHOULD). 예를 들어 확장 매개변수 "example"의 유효하지 않은 값의 집합을 식별하는 에러의 이름을 "example_invalid"로 지정할 것을 권장한다(SHOULD).

```
error      = 1*error-char
error-char = %x20-21 / %x23-5B / %x5D-7E
```

## 9. Native Applications

네이티브 애플리케이션은 리소스 소유자가 사용하는 디바이스에서 설치되어 실행되는 클라이언트이다(예: 데스크탑 애플리케이션, 네이티브 모바일 애플리케이션). 네이티브 애플리케이션은 보안, 플랫폼 기능 및 전반적인 최종 사용자 경험과 관련해 특별한 고려가 필요하다.

권한 부여 엔드포인트는 클라이언트와 리소스 소유자의 사용자 에이전트 간에 상호작용을 요구한다. 네이티브 애플리케이션은 외부의 사용자 에이전트를 호출하거나 애플리케이션에 내장된 사용자 에이전트를 호출할 수 있다. 예를 들면:

- 외부 사용자 에이전트 - 네이티브 애플리케이션은 클라이언트를 핸들러로 호출하도록 운영체제에 등록된 스키마를 가진 리디렉션 URI를 사용하거나, 자격 증명을 수동으로 복사 붙여넣기 하거나, 로컬 웹 서버를 실행하거나, 사용자 에이전트 확장을 설치하거나, 클라이언트의 제어 하에 있는 서버 호스팅 리소스를 식별하는 리디렉션 URI를 제공함으로써 권한 부여 서버로부터의 응답을 캡쳐할 수 있다. 그 다음 네이티브 애플리케이션은 응답을 사용할 수 있다.
- 내장 사용자 에이전트 - 네이티브 애플리케이션은 리소스를 불러오는 동안 발생하는 상태 변화를 모니터링 하거나, 사용자 에이전트의 쿠키 저장소를 액세스 하는 방법으로 내장 사용자 에이전트에 직접 접근하여 응답을 얻는다.

외부 또는 내장 사용자 에이전트 중 하나를 선택할 때 개발자는 아래의 사항을 고려한다:

- 외부 사용자 에이전트는 리소스 소유자가 이미 권한 부여 서버와 활성화된 세션을 보유해서 재인증할 필요가 없기 때문에 완료율을 향상할 수 있다. 이것은 익숙한 최종 사용자 경험과 기능을 제공한다. 또한 리소스 소유자는 사용자 에이전트의 기능 또는 확장의 도움을 받을 수 있다. (예: 패스워드 매니저, 2단계 장치 판독기)
- 내장 사용자 에이전트는 문맥을 전환하거나 새 윈도우를 열지 않아도 되기 때문에 사용성을 향상시킬 수 있다.
- 내장 사용자 에이전트는 대부분의 외장 사용자 에이전트에는 존재하는 시각적 보호에 액세스 하지 않고 비식별된 윈도우에서 인증하기 때문에 보안 문제를 제기한다. 내장 사용자 에이전트는 불확실한 인증 요청을 신뢰하도록 최종 사용자를 교육한다(피싱 공격이 실행되기 쉬워짐).

암시적 권한 부여(implicit grant) 유형과 권한 부여 코드(authorization code grant) 유형 중에 선택할 때는 아래의 사항이 고려되어야 한다:

- 권한 부여 코드(authorization code grant) 유형을 사용하는 네이티브 애플리케이션은 클라이언트 자격증명을 사용하지 않고 수행할 것을 권장한다(SHOULD). 네이티브 애플리케이션은 클라이언트 자격증명을 기밀로 유지할 수 없기 때문이다.
- 암시적 권한 부여(implicit grant) 유형 흐름을 사용할 경우, 리프레시 토큰은 리턴되지 않기 때문에 액세스 토큰이 만료된다면 권한 부여 과정을 반복해야 한다.

## 10. Security Considerations

유연하고 확장성 있는 프레임워크로서, OAuth의 보안 고려사항은 많은 요인에 의존한다. 아래의 섹션은 구현자에게 섹션 2.1에 설명된 세 가지 클라이언트 프로파일(웹 애플리케이션, 사용자 에이전트 기반 애플리케이션, 네이티브 애플리케이션)에 초점을 맞춘 보안 가이드라인을 제공한다.

포괄적인 OAuth 보안 모델과 분석, 프로토콜 설계의 배경은 [OAuth-THREATMODEL](https://datatracker.ietf.org/doc/html/rfc6749#ref-OAuth-THREATMODEL)에서 제공된다.

### 10.1. Client Authentication

권한 부여 서버는 클라이언트 인증을 위해 웹 애플리케이션 클라이언트와 클라이언트 자격증명을 설정한다. 권한 부여 서버는 클라이언트 비밀번호보다 강력한 클라이언트 인증 수단을 고려하도록 권장한다. 웹 애플리케이션 클라이언트는 반드시 클라이언트 비밀번호 및 다른 클라이언트 자격증명의 기밀성을 보장해야 한다(MUST).

권한 부여 서버는 애플리케이션이나 사용자 에이전트 기반의 애플리케이션 클라이언트에는 클라이언트 인증 목적의 클라이언트 비밀번호 또는 다른 클라이언트 자격증명을 발행해서는 안 된다(MUST NOT). 권한 부여 서버는 지정된 디바이스에 지정된 네이티브 애플리케이션을 설치하기 위해서는 클라이언트 비밀번호 또는 클라이언트 자격증명을 발급할 수 있다(MAY).

클라이언트 인증이 불가능할 때 권한 부여 서버는 클라이언트의 신원 확인을 위한 수단을 사용할 것을 권장한다(SHOULD). 예를 들어 클라이언트 리디렉션 URI 등록을 요구하거나 리소스 소유자가 신원을 확인하도록 요청한다. 리소스 소유자에게 권한을 요청할 때, 유효한 리디렉션 URI는 클라이언트의 신원을 확인하는데는 충분하지 않지만 리소스 소유자의 권한 부여를 얻은 다음에는 위조된 클라이언트에 자격증명을 전달하는 것을 방지할 수 있다.

권한 부여 서버는 인증되지 않은 클라이언트와 상호작용하는 것의 잠재적 보안 위협을 고려해야 하고, 해당 클라이언트에게 발급된 다른 자격증명(예: 리프리시 토큰)의 잠재적인 노출을 제한하기 위해 조치해야 한다.

### 10.2. Client Impersonation (클라이언트 사칭)

클라이언트 자격증명의 기밀 유지를 실패하거나 유지할 수 없다면 악의적인 클라이언트가 다른 클라이언트를 사칭하고 보호 리소스에 대한 액세스 권한을 얻을 수 있다.

권한 부여 서버는 클라이언트를 가능할 때마다 인증해야 한다(MUST). 클라이언트의 특성상 권한 부여 서버가 클라이언트를 인증할 수 없다면, 권한 부여 서버는 권한 부여 응답을 받는 모든 리디렉션 URI를 등록할 것을 요구하고(MUST), 그런 잠재적인 악의적 클라이언트로부터 리소스 소유자를 보호하는 다른 수단을 활용할 것을 권장한다(SHOULD). 예를 들어 권한 부여 서버는 클라이언트와 그 출처를 식별하는데 리소스 소유자를 참여시킬 수 있다.

권한 부여 서버는 명시적인 리소스 소유자 인증을 강요할 것과, 리소스 소유자에게 클라이언트와 요청된 권한의 범위 및 생명주기에 대한 정보를 제공할 것을 권장한다(SHOULD). 현재 클라이언트의 컨텍스트에서 정보를 검토하고 요청을 허가할지 거부할지는 리소스 소유자에게 달려있다.

권한 부여 서버는 반복되는 권한 부여 요청이 위조된 클라이언트가 아닌 원래의 클라이언트로부터 온 것을 보증하기 위해 클라이언트를 인증하지 않거나, 다른 수단에 의존하지 않고서는(리소스 소유자의 능동적인 상호작용 없이는) 자동으로 권한 부여 요청을 처리하지 않을 것을 권장한다(SHOULD NOT).

### 10.3. Access Tokens

액세스 토큰(및 기밀 유지된 액세스 토큰 속성) 자격증명은 전송과 저장 시 반드시 기밀이 유지되어야 하고, 권한 부여 서버와 해당 액세스 토큰이 유효한 리소스 서버, 해당 토큰이 발급된 클라이언트 사이에서만 공유해야 한다(MUST). 액세스 토큰 자격증명은 섹션 1.6에 설명된 것처럼 [RFC2818](https://datatracker.ietf.org/doc/html/rfc2818)에서 정의하는 서버 인증과 함께 TLS를 사용해서 전송해야 한다(MUST).

암시적 권한 부여(implicit grant) 유형을 사용할 때, 액세스 토큰은 URI 프래그먼트로 전송되어 허가되지 않은 당사자에게 노출될 수 있다.

클라이언트는 필요한 최소한의 범위로 액세스 토큰을 요청할 것을 권장한다(SHOULD). 권한 부여 서버는 요청의 범위를 존중하는 방법을 선택할 때 클라이언트의 신원을 고려할 것을 권장하며(SHOULD), 요청된 것보다 적은 권한으로 액세스 토큰을 발급할 수 있다(MAY).

이 명세서는 리소스 서버가 주어진 클라이언트로가 제시한 액세스 토큰이 권한 부여 서버가 해당 클라이언트로 발급한 것이 맞는지 확인하는 방법을 제공하지 않는다.

### 10.4. Refresh Tokens

권한 부여 서버는 웹 애플리케이션 클라이언트 및 네이티브 애플리케이션 클라이언트에 리프레시 토큰을 발급할 수 있다(MAY).

리프리세 토큰은 전송과 저장 시 기밀로 유지되어야 하며, 권한 부여 서버와 해당 리프레시 토큰이 발급된 클라이언트 사이에서만 공유해야 한다(MUST). 권한 부여서버는 리프레시 토큰과 그것을 발급받은 클라이언트 사이의 바인딩을 유지해야 한다(MUST). 섹션 1.6에 설명된 것처럼 리프레시 토큰은 TLS를 사용해 [RFC2818](https://datatracker.ietf.org/doc/html/rfc2818)에 정의된 서버 인증과 함께 전송해야 한다(MUST).

권한 부여 서버는 클라이언트의 신원을 인증할 수 있을 때마다 리프레시 토큰과 클라이언트 사이의 바인딩을 검증해야 한다(MUST). 클라이언트 인증이 불가능하다면 권한 부여 서버는 리프레시 토큰 남용을 감지하는 다른 수단을 배포할 것을 권장한다(SHOULD).

예를 들어 권한 부여 서버는 액세스 토큰 새로고침 응답마다 새로운 리프레시 토큰을 발급하는, 리프레시 토큰 순환을 채용할 수 있다. 이전의 리프레시 토큰은 무효화되지만 권한 부여 서버에서는 유지된다. 리프레시 토큰이 손상된 다음 공격자와 합법적인 사용자 모두가 사용하게 된다면, 그들 중 하나는 무효화된 리프레시 토큰을 제시하여 권한 부여 서버에 위반 사실에 대해 알리게 된다.

권한 부여 서버는 허가되지 않은 당사자에 의해 리프레시 토큰이 생성 또는 수정되거나, 유효한 리프레시 토큰을 만들기 위한 추론을 할 수 없도록 보장해야 한다(MUST).

### 10.5. Authorization Codes

권한 부여 코드(authorization code)의 전송은 안전한 채널에서 이루어지도록 할 것을 권장하며(SHOULD), 클라이언트는 URI가 네트워크 리소스를 식별할 경우 리디렉션 URI와 함께 TLS를 사용할 것을 권장한다(SHOULD). 권한 부여 코드는 사용자 에이전트의 리디렉션을 통해 전송되기 때문에, 사용자 에이전트의 히스토리와 HTTP 리퍼러 헤더(referrer headers)를 통해 잠재적으로 노출될 가능성이 있다.

권한 부여 코드는 일반 텍스트 전달자(bearer) 자격증명으로 동작하는데, 권한 부여 서버의 권한 부여를 받은 리소스 소유자가 권한 부여 과정을 마치기 위해 클라이언트로 돌아오는 리소스 소유자와 동일한지 확인하기 위해 사용한다. 그래서 클라이언트가 자체 리소스 소유자 인증을 권한 부여 코드에 의존하는 경우, 클라이언트 리디렉션 엔드포인트는 반드시 TLS 사용을 요구해야 한다(MUST).

권한 부여 코드는 수명이 짧고 일회용이어야 한다(MUST). 권한 부여 코드를 액세스 토큰으로 교환하려는 다수의 시도를 발견한 경우, 권한 부여 서버는 해당 손상된 권한 부여 코드를 기반으로 기존에 승인된 모든 액세스 토큰을 취소하려고 시도할 것을 권장한다(SHOULD).

클라이언트를 인증할 수 있는 경우, 권한 부여 서버는 클라이언트를 인증하고 권한 부여 코드가 해당 클라이언트에 발급된 것이 맞는지 확인해야 한다(MUST).

### 10.6. Authorization Code Redirection URI Manipulation

권한 부여 코드(authorization code grant) 유형 사용해 권한 부여를 요청할 때 클라이언트는 "redirect_uri" 매개변수를 통해 리디렉션 URI를 지정할 수 있다. 만약 공격자가 리디렉션 URI의 값을 조작할 수 있다면, 권한 부여 서버가 리소스 소유자의 사용자 에이전트를 권한 부여 코드와 함께 공격자의 제어 하에 있는 URI로 보낼 수 있다.

공격자는 합법적인 클라이언트 상에서 계정을 생성하고 권한 부여 과정을 시작할 수 있다. 공격자의 사용자 에이전트가 액세스 권한을 획득하기 위해 권한 부여 서버로 보내지면 공격자는 합법적인 클라이언트가 제공한 리디렉션 URI를 가져와서 공격자의 제어 하에 있는 URI로 교체할 수 있다. 그 뒤 공격자는 피해자가 합법적인 클라이언트에 대한 액세스 권한을 부여하기 위해 조작된 링크를 따르도록 속인다.

권한 부여 서버에 도착한 다음 피해자는 정당하고 신뢰할 수 있는 클라이언트를 대신하여 정상적이고 유효한 요청을 받고, 요청을 승인한다. 그 다음 피해자는 권한 부여 코드를 가지고 공격자의 제어 하에 있는 엔드포인트로 리디렉트 한다. 공격자는 클라이언트가 제공한 원래의 리디렉션 URI를 사용해 권한 부여 코드를 클라이언트로 전송하여 권한 부여 과정을 완료한다. 클라이언트는 권한 부여 코드를 액세스 토큰으로 교환하고 공격자의 클라이언트 계정과 연결하여, 공격자는 그때부터 클라이언트를 통해서 희생자로부터 허가받은 보호된 리소스에 액세스 할 수 있다.

그런 공격을 막기 위해서 권한 부여 서버는 권한 부여 코드를 얻기 위해 사용하는 리디렉션 URI와 권한 부여 코드를 액세스 토큰으로 교환할 때 제공되는 리디렉션 URI가 동일한지 확인해야 한다(MUST). 권한 부여 서버는 클라이언트가 자신의 리디렉션 URI를 등록하도록 공개(public) 클라이언트에게는 반드시 요구하며(MUST), 기밀(confidential) 클라이언트에게는 요구할 것을 권장한다(SHOULD). 요청에서 리디렉션 URI가 제공된 경우 권한 부여 서버는 등록된 값과 검증해야 한다(MUST).

### 10.7. Resource Owner Password Credentials

리소스 소유자 비밀번호 자격증명 권한 부여 유형은 레거시 또는 마이그레이션의 이유로 종종 사용된다. 이 방법은 클라이언트에 사용자 이름과 비밀번호를 저장하는 전반적인 위험을 경감하지만, 높은 권한이 있는 자격증명을 클라이언트에 노출할 필요성을 제거하지 않는다.

이 권한 부여 유형은 다른 권한 부여 유형에 비해 높은 위험성을 수반하는데, 이 프로토콜이 피하고자 하는 비밀번호 안티 패턴을 유지하기 때문이다. 클라이언트가 비밀번호를 남용하거나 비밀번호가 공격자에게 의도치 않게 노출될 수 있다(예: 로그 파일 도는 클라이언트가 기록하는 기타 기록을 통해서)

추가로 리소스 소유자가 권한 부여 과정을 통제하지 않기 때문에(리소스 소유자의 관여는 클라이언트에게 자신의 자격증명을 전달하면 끝난다), 클라이언트는 리소스 소유자가 원하는 것보다 넓은 범위의 액세스 토큰을 얻을 수 있다. 권한 부여 서버는 이 권한 부여 유형을 통해 발급되는 액세스 토큰의 범위와 생명주기을 고려해야 한다.

권한 부여 서버와 클라이언트는 이 권한 뷰여 유형의 사용을 최소화하고 가능하다면 다른 권한 부여 유형을 활용할 것을 권장한다(SHOULD).

### 10.8. Request Confidentiality

액세스 토큰, 리프레시 토큰, 리소스 소유자 비밀번호, 클라이언트 자격증명을 투명하게 전송해서는 안 된다(MUST NOT). 권한 부여 코드를 투명하게 전송하지 않을 것을 권장한다(SHOULD NOT).

"state"와 "scope" 매개변수는 안전하지 않은 채널로 전송되거나 안전하지 않게 저장될 수 있기 때문에 클라이언트나 리소스 소유자의 민감한 정보는 평문으로 포함하지 않을 것을 권장한다(SHOULD NOT).

### 10.9. Ensuring Endpoint Authenticity (엔드포인트 신뢰성 보장)

중간자 공격을 방지하기 위해 권한 부여 서버는 권한 부여 엔드포인트 및 토큰 엔드포인트로 전송되는 모든 요청에 대해 [RFC2818](https://datatracker.ietf.org/doc/html/rfc2818)에 정의된 것처럼 서버 인증과 함께 TLS를 사용하도록 해야 한다(MUST). 클라이언트는 [RFC6125](https://datatracker.ietf.org/doc/html/rfc6125)에 정의와 서버 신원 인증을 위한 해당 요구사항을 따라서 권한 부여 서버의 TLS 인증서를 검증해야 한다(MUST).

### 10.10. Credentials-Guessing Attacks

권한 부여 서버는 액세스 토큰, 권한 부여 코드, 리프레시 토큰, 리소스 소유자 비밀번호, 클라이언트 자격증명을 추측하는 공격을 방지해야 한다(MUST).

공격자가 생성된 토큰(및 최종 사용자가 처리하도록 의도되지 않은 다른 자격증명)을 추측할 확률은 반드시 2^(-128) 보다 작거나 같아야 하며(MUST), 2^(-160) 보다 작거나 같을 것을 권장한다(SHOULD).

권한 부여 서버는 최종 사용자용 자격증명을 보호하기 위한 다른 수단을 활용해야 한다(MUST).

### 10.11. Phishing Attacks

이 명세서 및 유사한 프로토콜이 널리 배포되면 최종 사용자들이 웹 사이트로 리디렉트 해서 비밀번호를 입력하도록 요구하는 방식에 익숙해질 수 있다. 최종 사용자가 자신의 자격증명을 입력하기 전에 이런 웹 사이트가 확실한지 검증하는 주의를 기울이지 않는다면 공격자들이 이런 사용법을 악용하여 리소스 소유자의 비밀번호를 훔칠 수 있다.

서비스 제공자는 이런 피싱 공격 노출 위험성에 대해 최종 사용자를 교육하도록 시도해야 하며 최종 사용자가 웹 사이트의 신뢰성을 쉽게 확인할 수 있는 메커니즘을 제공해야 한다. 클라이언트 개발자는 사용자 에이전트(외부, 내장)와 상호작용하는 방식의 보안적인 의미를 고려하고, 권한 부여 서버의 신뢰성을 검증하는 최종 사용자의 능력도 고려해야 한다.

이런 피싱 공격의 위험을 줄이기 위해 권한 부여 서버는 최종 사용자의 상호작용하는 모든 엔드포인트에서 TLS를 사용해야 한다(MUST).

### 10.12. Cross-Site Request Forgery

교차 사이트 요청 위조(CSRF: Cross-site request forgery)는 피해를 입은 최종 사용자의 사용자 에이전트가 악의적인 URI(예: 오해의 소지가 있는 링크, 이미지 또는 리디렉션으로 사용자 에이전트로 제공)로부터 신뢰할 수 있는 서버(일반적으로 유효한 세션 쿠키의 존재를 통해 설정됨)를 따르도록 하는 악용 방식이다.

클라이언트 리디렉션 URI에 대한 CSRF 공격으로 공격자는 자신의 권한 부여 코드 또는 액세스 토큰을 주입할 수 있으며, 이로 인해 클라이언트는 피해자가 아닌 공격자의 보호 리소스와 연결된 액세스 토큰을 사용할 수 있다(예: 피해자의 은행 계좌 정보를 공격자가 제어하는 보호 리소스에 저장).

클라이언트는 자신의 리디렉션 URI에 반드시 CSRF 방어를 구현해야 한다(MUST). 일반적으로 리디렉션 URI 엔드포인트로 보내는 모든 요청에 대해, 사용자 에이전트의 인증 상태에 바인딩되는 값(예: 사용자 에이전트를 인증하는 세션 쿠키의 해시값)을 요청에 포함하도록 요구해서 해결할 수 있다. 클라이언트는 권한 부여 요청을 생성할 때 이 값을 권한 부여 서버로 전달하기 위해 "state" 요청 매개변수를 활용하는 것을 권장한다(SHOULD).

최종 사용자로부터 권한을 받은 다음, 권한 부여 서버는 요구했던 바인딩 값을 "state" 매개변수에 포함시켜서 최종 사용자의 사용자 에이전트를 클라이언트에게 리디렉트한다. 이 바인딩된 값을 사용자 에이전트의 인증 상태와 바인딩된 값과 일치시켜서 클라이언트는 요청의 유효성을 검증할 수 있다. CSRF 보호에 사용하는 바인딩 값은 추측 불가능한 값(섹션 10.10에 설명)을 포함해야 하며(MUST), 사용자 에이전트의 인증 상태(예: 세션 쿠키, HTML5 로컬 스토리지)는 클라이언트와 사용자 에이전트만 접근할 수 있는 위치에 보관 해야 한다(MUSt). (예: same-origin 정책으로 보호)

권한 부여 서버는의 권한 부여 엔드포인트에 대한 CSRF 공격으로 인해 최종 사용자가 참여하거나 경고 받는 일 없이 공격자가 악의적인 클라이언트를 위한 최종 사용자 허가를 얻을 수 있다.

권한 부여 서버는 자신의 권한 부여 엔드포인트에 CSRF 방어를 구현해야 하고, 악의적인 클라이언트가 리소스 소유자의 인식 및 명시적 동의 없이 권한을 획득하지 않도록 보장해야 한다(MUST).

### 10.13. Clickjacking

클릭재킹에서 공격자는 합법적인 클라이언트에 등록한 다음, 악의적인 사이트를 만들고 더미 버튼 위에다 권한 부여 서버의 권한 부여 엔드포인트 웹페이지를 불러오는 투명한 iframe을 겹친다. 이 더미 버튼은 권한 부여 페이지의 중요 버튼의 바로 아래에 배치해서 세심하게 만든다. 최종 사용자가 눈에 보이는 잘못된 버튼을 클릭하면, 실제로는 투명한 권한 부여 페이지의 버튼을 클릭하는 것이다("Authorize" 버튼 같은). 이 방법은 공격자가 리소스 소유자를 속여서 최종 사용자가 모른채로 클라이언트 액세스 권한을 허가하도록 할 수 있다.

이런 형태의 공격을 방지하기 위해 네이티브 애플리케이션은 최종 사용자 허가를 요청할 때 애플리케이션에 내장된 브라우저 대신 외부 브라우저를 사용하는 것을 권장된다(SHOULD). 대부분의 최신 브라우저에서는 권한 부여 서버가 "x-frame-options" 헤더(비표준)을 사용해 iframe을 강제로 피할 수 있다. 이 헤더는 "deny" 와 "sameorigin" 두 값을 가질 수 있으며, 이 값은 각각 모든 프레임 또는 다른 오리진의 사이트를 프레임 하는 것을 방지한다. 구버전 브라우저에서는 자바스크립트의 프레임 방지 기술(JavaScript frame-busting techniques)을 사용할 수 있지만, 일부 브라우저에서는 효과적이지 않을 수 있다.

### 10.14. Code Injection and Input Validation

코드 인젝션 공격은 입력값 또는 다른 외부 변수가 애플리케이션에서 정제되지 않은 상태로 사용되어 애플리케이션 로직을 변경하는 경우에 발생한다. 이것은 공격자가 애플리케이션 장치 또는 그 데이터에 대한 접근을 얻도록 해서 서비스 거부 또는 광범위한 악의적인 부작용을 초래할 수 있다.

권한 부여 서버와 클라이언트는 수신하는 모든 값, 특히 "state" 와 "redirect_uri" 매개변수의 값을 정제하고 가능한 한 검증해야 한다(MUST).

### 10.15. Open Redirectors

권한 부여 서버, 권한 부여 엔드포인트, 클라이언트 리디렉션 엔드포인트는 부적절하게 설정될 수 있으며 열린 리디렉터로 동작할 수 있다. 오픈 리디렉터란 아무런 검증을 하지 않고 매개변수가 지정하는 위치로 사용자 에이전트를 자동으로 리디렉션하는 엔드포인트이다.

오픈 리디렉터는 피싱 어택에 이용될 수 있으며, 친숙하고 신뢰할 수 있는 대상의 URI 권한 구성요소를 사용해 공격자가 최종 사용자를 악의적인 사이트에 방문하게 하도록 사용될 수 있다. 게다가 클라이언트가 리디렉션 URI의 일부분만 등록할 수 있도록 권한 부여 서버가 허용한다면, 공격자는 클라이언트가 운영하는 오픈 리디렉터를 사용해 권한 부여 서버의 검증은 통과하지만 공격자의 제어 하에 있는 엔드포인트로 권한 부여 코드 또는 액세스 토큰을 전달하는 리디렉션 URI를 구성할 수 있다.

### 10.16. Misuse of Access Token to Impersonate Resource Owner in Implicit Flow (implicit 흐름에서 리소스 소유자를 사칭하기 위한 액세스 토큰의 오용)

암시적(implicit) 흐름을 사용하는 공개 클라이언트(public client)에 대해, 이 명세서는 클라이언트가 액세스 토큰이 어떤 클라이언트에게 발급된 것인지 결정하는 방법을 제공하지 않는다.

리소스 소유자는 액세스 토큰을 공격자의 악의적인 클라이언트에 허가해서 리소스에 대한 액세스를 기꺼이 위임할 수 있다. 이런 일은 피싱이나 다른 구실로 인해 일어날 수 있다. 또한 공격자는 다른 메커니즘을 통해서도 토큰을 훔칠 수 있다. 그런 다음 공격자는 합법적인 공개 클라이언트에 액세스 토큰을 제공해서 리소스 소유자를 사칭하려고 시도할 수 있다.

암시적(implicit) 흐름(response_type=token)에서, 공격자는 권한 부여 서버의 응답으로부터 쉽게 토큰을 전환하여 실제 액세스 토큰을 이전에 공격자에게 발급된 토큰으로 교체할 수 있다.

클라이언트의 사용자를 식별하기 위해 백 채널로 전달되는 액세스 토큰에 의존하는 네이티브 애플리케이션과 통신하는 서버는 임의의 도둑맞은 액세스 토큰을 주입할 수 있는 손상된 애플리케이션을 생성하는 공격자에 의해 유사하게 손상될 수 있다.

리소스 소유자만 유효한 액세스 토큰을 제시할 수 있다고 가정하는 모든 공개 클라이언트(public client)는 이런 유형의 공격에 취약하다.

이런 유형의 공격은 합법적인 클라이언트 상의 리소스 소유자에 대한 정보를 공격자(악의적인 클라이언트)에게 노출할 수 있다. 또한 공격자가 액세스 토큰과 권한 부여 코드를 부여받은 원래의 리소스 소유자와 동일한 권한으로 합법적인 클라이언트에서 작업을 수행할 수 있도록 한다.

리소스 소유자를 클라이언트에 인증하는 것은 이 명세서의 범위를 벗어난다. 최종 사용자 인증을 클라이언트에게 위임하는 형태로 권한 부여 과정을 사용하는 모든 명세는(예: 타사 로그인 서비스), 클라이언트가 액세스 토큰이 자신이 사용하도록 발급된 것인지 결정할 수 있도록 하는 추가적인 보안 메커니즘 없이 암시적(implicit) 흐름을 사용할 수 없다(MUST NOT). (예: 청중 제한 액세스 토큰)

## 11. IANA Considerations

### 번역 생략 (11.1.1 ~ 11.4.1)

서론에서 언급했듯, 이 섹션의 세부 내용은 번역하지 않고 원문을 첨부함.

### 11.1. OAuth Access Token Types Registry

이 명세서는 OAuth 액세스 토큰 유형 레지스트리를 설정한다.

액세스 토큰 유형은 한 명 이상의 지명 전문가의 조언에 따라 oauth-ext-review@ietf.org 메일링 리스트에서 2주간 리뷰 기간을 거친 다음 특별 명세([[RFC5226](https://datatracker.ietf.org/doc/html/rfc5226)])에 등록된다. 그러나 발행에 앞서 값을 할당하기 위해 지정 전문가는 해당 명세가 발행되는 것에 만족한다면 등록을 승인할 수 있다.

등록 요청은 검토 및 의견 제시를 위해 oauth-ext-review@ietf.org로 보내야 하고 적절한 제목을 지정해야 한다. (예: 액세스 토큰 타입에 대한 요청: 예시")

검토 기간 안에 지정 전문가는 등록 요청을 승인 또는 거절하고, 그 결정을 검토 리스트와 IANA로 전달한다. 거절할 경우 설명을 포함해야 하고, 가능하다면 요청을 성공적으로 수행하기 위한 방법에 대한 제안을 포함해야 한다.

IANA는 지정 전문로부터의 레지스트리 업데이트만 승인해야 하며 등록에 대한 모든 요청을 검토 메일링 리스트로 보내야 한다.

#### 11.1.1 Registration Template

Type name:  
The name requested (e.g., "example").

Additional Token Endpoint Response Parameters:
Additional response parameters returned together with the
"access_token" parameter. New parameters MUST be separately
registered in the OAuth Parameters registry as described by
[Section 11.2](https://datatracker.ietf.org/doc/html/rfc6749#section-11.2).

HTTP Authentication Scheme(s):  
The HTTP authentication scheme name(s), if any, used to
authenticate protected resource requests using access tokens of
this type.

Change controller:  
For Standards Track RFCs, state "IETF". For others, give the name
of the responsible party. Other details (e.g., postal address,
email address, home page URI) may also be included.

Specification document(s):  
Reference to the document(s) that specify the parameter,
preferably including a URI that can be used to retrieve a copy of
the document(s). An indication of the relevant sections may also
be included but is not required.

### 11.2. OAuth Parameters Registry

This specification establishes the OAuth Parameters registry.

Additional parameters for inclusion in the authorization endpoint
request, the authorization endpoint response, the token endpoint
request, or the token endpoint response are registered with a
Specification Required ([[RFC5226](https://datatracker.ietf.org/doc/html/rfc5226)]) after a two-week review period on
the oauth-ext-review@ietf.org mailing list, on the advice of one or
more Designated Experts. However, to allow for the allocation of
values prior to publication, the Designated Expert(s) may approve
registration once they are satisfied that such a specification will
be published.

Registration requests must be sent to the oauth-ext-review@ietf.org
mailing list for review and comment, with an appropriate subject
(e.g., "Request for parameter: example").

Within the review period, the Designated Expert(s) will either
approve or deny the registration request, communicating this decision
to the review list and IANA. Denials should include an explanation
and, if applicable, suggestions as to how to make the request
successful.

IANA must only accept registry updates from the Designated Expert(s)
and should direct all requests for registration to the review mailing
list.

#### 11.2.1. Registration Template

Parameter name:  
The name requested (e.g., "example").

Parameter usage location:  
The location(s) where parameter can be used. The possible
locations are authorization request, authorization response, token
request, or token response.

Change controller:  
For Standards Track RFCs, state "IETF". For others, give the name
of the responsible party. Other details (e.g., postal address,
email address, home page URI) may also be included.

Specification document(s):  
Reference to the document(s) that specify the parameter,
preferably including a URI that can be used to retrieve a copy of
the document(s). An indication of the relevant sections may also
be included but is not required.

#### 11.2.2. Initial Registry Contents

The OAuth Parameters registry's initial contents are:

o Parameter name: client_id  
o Parameter usage location: authorization request, token request  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: client_secret  
o Parameter usage location: token request  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: response_type  
o Parameter usage location: authorization request  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: redirect_uri  
o Parameter usage location: authorization request, token request  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: scope  
o Parameter usage location: authorization request, authorization  
response, token request, token response  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: state  
o Parameter usage location: authorization request, authorization  
response  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: code  
o Parameter usage location: authorization response, token request  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: error_description  
o Parameter usage location: authorization response, token response  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: error_uri  
o Parameter usage location: authorization response, token response  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: grant_type  
o Parameter usage location: token request  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: access_token  
o Parameter usage location: authorization response, token response  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: token_type  
o Parameter usage location: authorization response, token response  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: expires_in  
o Parameter usage location: authorization response, token response  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: username  
o Parameter usage location: token request  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: password  
o Parameter usage location: token request  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Parameter name: refresh_token  
o Parameter usage location: token request, token response  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

### 11.3. OAuth Authorization Endpoint Response Types Registry

This specification establishes the OAuth Authorization Endpoint
Response Types registry.

Additional response types for use with the authorization endpoint are
registered with a Specification Required ([[RFC5226](https://datatracker.ietf.org/doc/html/rfc5226)]) after a two-week
review period on the oauth-ext-review@ietf.org mailing list, on the
advice of one or more Designated Experts. However, to allow for the
allocation of values prior to publication, the Designated Expert(s)
may approve registration once they are satisfied that such a
specification will be published.

Registration requests must be sent to the oauth-ext-review@ietf.org
mailing list for review and comment, with an appropriate subject
(e.g., "Request for response type: example").

Within the review period, the Designated Expert(s) will either
approve or deny the registration request, communicating this decision
to the review list and IANA. Denials should include an explanation
and, if applicable, suggestions as to how to make the request
successful.

IANA must only accept registry updates from the Designated Expert(s)
and should direct all requests for registration to the review mailing
list.

#### 11.3.1. Registration Template

Response type name:  
The name requested (e.g., "example").

Change controller:  
For Standards Track RFCs, state "IETF". For others, give the name
of the responsible party. Other details (e.g., postal address,
email address, home page URI) may also be included.

Specification document(s):  
Reference to the document(s) that specify the type, preferably
including a URI that can be used to retrieve a copy of the
document(s). An indication of the relevant sections may also be
included but is not required.

#### 11.3.2. Initial Registry Contents

The OAuth Authorization Endpoint Response Types registry's initial
contents are:

o Response type name: code  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

o Response type name: token  
o Change controller: IETF  
o Specification document(s): [RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)

### 11.4. OAuth Extensions Error Registry

This specification establishes the OAuth Extensions Error registry.

Additional error codes used together with other protocol extensions
(i.e., extension grant types, access token types, or extension
parameters) are registered with a Specification Required ([[RFC5226](https://datatracker.ietf.org/doc/html/rfc5226))
after a two-week review period on the oauth-ext-review@ietf.org
mailing list, on the advice of one or more Designated Experts.
However, to allow for the allocation of values prior to publication,
the Designated Expert(s) may approve registration once they are
satisfied that such a specification will be published.

Registration requests must be sent to the oauth-ext-review@ietf.org
mailing list for review and comment, with an appropriate subject
(e.g., "Request for error code: example").

Within the review period, the Designated Expert(s) will either
approve or deny the registration request, communicating this decision
to the review list and IANA. Denials should include an explanation
and, if applicable, suggestions as to how to make the request
successful.

IANA must only accept registry updates from the Designated Expert(s)
and should direct all requests for registration to the review mailing
list.

#### 11.4.1. Registration Template

Error name:  
The name requested (e.g., "example"). Values for the error name
MUST NOT include characters outside the set %x20-21 / %x23-5B /
%x5D-7E.

Error usage location:  
The location(s) where the error can be used. The possible
locations are authorization code grant error response
([Section 4.1.2.1](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2.1)), implicit grant error response
([Section 4.2.2.1](https://datatracker.ietf.org/doc/html/rfc6749#section-4.2.2.1)), token error response ([Section 5.2](https://datatracker.ietf.org/doc/html/rfc6749#section-5.2)), or resource
access error response ([Section 7.2](https://datatracker.ietf.org/doc/html/rfc6749#section-7.2)).

Related protocol extension:  
The name of the extension grant type, access token type, or
extension parameter that the error code is used in conjunction
with.

Change controller:  
For Standards Track RFCs, state "IETF". For others, give the name
of the responsible party. Other details (e.g., postal address,
email address, home page URI) may also be included.

Specification document(s):  
Reference to the document(s) that specify the error code,
preferably including a URI that can be used to retrieve a copy of
the document(s). An indication of the relevant sections may also
be included but is not required.

## A. Argumented Backus-Naur Form (ABNF) Syntax

이 섹션은 [[RFC5234](https://datatracker.ietf.org/doc/html/rfc5234)]의 표기법을 사용해 이 명세서에 정의된 요소에 대한 ABNF 구문 설명을 제공한다. 아래 ABNF는 유니코드 코드 포인트 [[W3C.REC-xml-20081126](https://datatracker.ietf.org/doc/html/rfc6749#ref-W3C.REC-xml-20081126)]로 정의된다. 문자는 일반적으로 UTF-8로 인코딩 된다. 요소들은 정의된 순서대로 표시된다.

일부 정의는 [[RFC3986](https://datatracker.ietf.org/doc/html/rfc3986)]에 따라 "URI-reference" 정의를 사용한다.

일부 정의는 아래의 일반적 정의를 사용한다.

```
     VSCHAR     = %x20-7E
     NQCHAR     = %x21 / %x23-5B / %x5D-7E
     NQSCHAR    = %x20-21 / %x23-5B / %x5D-7E
     UNICODECHARNOCRLF = %x09 /%x20-7E / %x80-D7FF /
                         %xE000-FFFD / %x10000-10FFFF
```

(UNICODECHARNOCRLF 정의는 섹션 2.2의 [[W3C.REC-xml-20081126](https://datatracker.ietf.org/doc/html/rfc6749#ref-W3C.REC-xml-20081126)] 문자 정의를 기반으로 하지만 캐리지 리턴과 라인피드 문자는 생략한다.)

### A.1."client_id" Syntax

The "client_id" element is defined in [Section 2.3.1](https://datatracker.ietf.org/doc/html/rfc6749#section-2.3.1):

client-id = \*VSCHAR

### A.2. "client_secret" Syntax

The "client_secret" element is defined in [Section 2.3.1](https://datatracker.ietf.org/doc/html/rfc6749#section-2.3.1):

client-secret = \*VSCHAR

### A.3. "response_type" Syntax

The "response_type" element is defined in Sections [3.1.1](https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.1) and [8.4](https://datatracker.ietf.org/doc/html/rfc6749#section-8.4):

response-type = response-name *( SP response-name )
response-name = 1*response-char
response-char = "\_" / DIGIT / ALPHA

### A.4. "scope" Syntax

The "scope" element is defined in [Section 3.3](https://datatracker.ietf.org/doc/html/rfc6749#section-3.3):

scope = scope-token *( SP scope-token )
scope-token = 1*NQCHAR

### A.5. "state" Syntax

The "state" element is defined in Sections [4.1.1](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1), [4.1.2](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2), [4.1.2.1](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2.1),
4.2.1, 4.2.2, and 4.2.2.1:

state = 1\*VSCHAR

### A.6. "redirect_uri" Syntax

The "redirect_uri" element is defined in Sections [4.1.1](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1), [4.1.3](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3),
and 4.2.1:

redirect-uri = URI-reference

### A.7. "error" Syntax

The "error" element is defined in Sections [4.1.2.1](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2.1), [4.2.2.1](https://datatracker.ietf.org/doc/html/rfc6749#section-4.2.2.1), [5.2](https://datatracker.ietf.org/doc/html/rfc6749#section-5.2),
7.2, and 8.5:

error = 1\*NQSCHAR

### A.8. "error_description" Syntax

The "error_description" element is defined in Sections [4.1.2.1](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2.1),
4.2.2.1, 5.2, and 7.2:

error-description = 1\*NQSCHAR

### A.9. "error_uri" Syntax

The "error_uri" element is defined in Sections [4.1.2.1](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2.1), [4.2.2.1](https://datatracker.ietf.org/doc/html/rfc6749#section-4.2.2.1), [5.2](https://datatracker.ietf.org/doc/html/rfc6749#section-5.2),
and 7.2:

error-uri = URI-reference

### A.10. "grant_type" Syntax

The "grant_type" element is defined in Sections [4.1.3](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3), [4.3.2](https://datatracker.ietf.org/doc/html/rfc6749#section-4.3.2), [4.4.2](https://datatracker.ietf.org/doc/html/rfc6749#section-4.4.2),
4.5, and 6:

grant-type = grant-name / URI-reference
grant-name = 1\*name-char
name-char = "-" / "." / "\_" / DIGIT / ALPHA

### A.11. "code" Syntax

The "code" element is defined in [Section 4.1.3](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3):

code = 1\*VSCHAR

### A.12. "access_token" Syntax

The "access_token" element is defined in Sections [4.2.2](https://datatracker.ietf.org/doc/html/rfc6749#section-4.2.2) and [5.1](https://datatracker.ietf.org/doc/html/rfc6749#section-5.1):

access-token = 1\*VSCHAR

### A.13. "token_type" Syntax

The "token_type" element is defined in Sections [4.2.2](https://datatracker.ietf.org/doc/html/rfc6749#section-4.2.2), [5.1](https://datatracker.ietf.org/doc/html/rfc6749#section-5.1), and [8.1](https://datatracker.ietf.org/doc/html/rfc6749#section-8.1):

token-type = type-name / URI-reference
type-name = 1\*name-char
name-char = "-" / "." / "\_" / DIGIT / ALPHA

### A.14. "expires_in" Syntax

The "expires_in" element is defined in Sections [4.2.2](https://datatracker.ietf.org/doc/html/rfc6749#section-4.2.2) and [5.1](https://datatracker.ietf.org/doc/html/rfc6749#section-5.1):

expires-in = 1\*DIGIT

### A.15. "username" Syntax

The "username" element is defined in [Section 4.3.2](https://datatracker.ietf.org/doc/html/rfc6749#section-4.3.2):

username = \*UNICODECHARNOCRLF

### A.16. "password" Syntax

The "password" element is defined in [Section 4.3.2](https://datatracker.ietf.org/doc/html/rfc6749#section-4.3.2):

password = \*UNICODECHARNOCRLF

### A.17. "refresh_token" Syntax

The "refresh_token" element is defined in Sections [5.1](https://datatracker.ietf.org/doc/html/rfc6749#section-5.1) and [6](https://datatracker.ietf.org/doc/html/rfc6749#section-6):

refresh-token = 1\*VSCHAR

### A.18. Endpoint Parameter Syntax

The syntax for new endpoint parameters is defined in [Section 8.2](https://datatracker.ietf.org/doc/html/rfc6749#section-8.2):

param-name = 1\*name-char
name-char = "-" / "." / "\_" / DIGIT / ALPHA

## Appendix B. Use of application/x-www-form-urlencoded Media Type

이 명세서가 발행되는 시점에는 "application/x-www-form-urlencoded" 미디어 타입이 [[W3C.REC-html401-19991224](https://datatracker.ietf.org/doc/html/rfc6749#ref-W3C.REC-html401-19991224)]의 섹션 17.13.4에 정의되어 있지만 IANA MIME 미디어 타입 레지스트리([http://www.iana.org/assignments/media-types](http://www.iana.org/assignments/media-types))에는 등록되지 않았다. 게다가 그 정의는 non-US-ASCII 문자를 고려하지 않았기 때문에 불완전하다.

이 미디어 타입을 사용해 페이로드를 생성할 때의 결점을 조정하기 위해, 먼저 이름과 값은 반드시 UTF-8 문자 인코딩 체계 [[RFC3629](https://datatracker.ietf.org/doc/html/rfc3629)]를 사용해 인코딩한다(MUST). 결과 옥텟 시퀀스는 그 다음 [[W3C.REC-html401-19991224](https://datatracker.ietf.org/doc/html/rfc6749#ref-W3C.REC-html401-19991224)]에 정의된 이스케이프 규칙을 사용해 추가로 인코딩 되어야 한다.

이 미디어 유형을 사용한 페이로드로부터 데이터를 추출할 때, 인코딩을 역순으로 수행하여 이름과 값을 얻기 위해 순차적으로 옥텟 시퀀스로 취급하고, UTF-8 문자 인코딩 쳬계를 사용해 디코딩 해야 한다.

예를 들어 여섯개의 유니코드 코드 포인트로 구성된 값은  
(1) U+0020 (SPACE), (2) U+0025 (PERCENT SIGN),  
(3) U+0026 (AMPERSAND), (4) U+002B (PLUS SIGN),  
(5) U+00A3 (POUND SIGN), and (6) U+20AC (EURO SIGN)  
아래의 옥텟 시퀀스로 인코딩 된다(16진수 표기법을 사용):

```
20 25 26 2B C2 A3 E2 82 AC
```

그러면 페이로드에서 아래처럼 나타난다:

```
+%25%26%2B%C2%A3%E2%82%AC
```

## Appendix C. Acknowledgements

The initial OAuth 2.0 protocol specification was edited by David
Recordon, based on two previous publications: the OAuth 1.0 community
specification [[RFC5849](https://datatracker.ietf.org/doc/html/rfc5849)], and OAuth WRAP (OAuth Web Resource
Authorization Profiles) [[OAuth-WRAP](https://datatracker.ietf.org/doc/html/rfc6749#ref-OAuth-WRAP)]. Eran Hammer then edited many
of the intermediate drafts that evolved into this RFC. The Security
Considerations section was drafted by Torsten Lodderstedt, Mark
McGloin, Phil Hunt, Anthony Nadalin, and John Bradley. The section
on use of the "application/x-www-form-urlencoded" media type was
drafted by Julian Reschke. The ABNF section was drafted by Michael
B. Jones.

The OAuth 1.0 community specification was edited by Eran Hammer and
authored by Mark Atwood, Dirk Balfanz, Darren Bounds, Richard M.
Conlan, Blaine Cook, Leah Culver, Breno de Medeiros, Brian Eaton,
Kellan Elliott-McCrea, Larry Halff, Eran Hammer, Ben Laurie, Chris
Messina, John Panzer, Sam Quigley, David Recordon, Eran Sandler,
Jonathan Sergent, Todd Sieling, Brian Slesinsky, and Andy Smith.

The OAuth WRAP specification was edited by Dick Hardt and authored by
Brian Eaton, Yaron Y. Goland, Dick Hardt, and Allen Tom.

This specification is the work of the OAuth Working Group, which
includes dozens of active and dedicated participants. In particular,
the following individuals contributed ideas, feedback, and wording
that shaped and formed the final specification:

Michael Adams, Amanda Anganes, Andrew Arnott, Dirk Balfanz, Aiden
Bell, John Bradley, Marcos Caceres, Brian Campbell, Scott Cantor,
Blaine Cook, Roger Crew, Leah Culver, Bill de hOra, Andre DeMarre,
Brian Eaton, Wesley Eddy, Wolter Eldering, Brian Ellin, Igor
Faynberg, George Fletcher, Tim Freeman, Luca Frosini, Evan Gilbert,
Yaron Y. Goland, Brent Goldman, Kristoffer Gronowski, Eran Hammer,
Dick Hardt, Justin Hart, Craig Heath, Phil Hunt, Michael B. Jones,
Terry Jones, John Kemp, Mark Kent, Raffi Krikorian, Chasen Le Hara,
Rasmus Lerdorf, Torsten Lodderstedt, Hui-Lan Lu, Casey Lucas, Paul
Madsen, Alastair Mair, Eve Maler, James Manger, Mark McGloin,
Laurence Miao, William Mills, Chuck Mortimore, Anthony Nadalin,
Julian Reschke, Justin Richer, Peter Saint-Andre, Nat Sakimura, Rob
Sayre, Marius Scurtescu, Naitik Shah, Luke Shepard, Vlad Skvortsov,
Justin Smith, Haibin Song, Niv Steingarten, Christian Stuebner,
Jeremy Suriel, Paul Tarjan, Christopher Thomas, Henry S. Thompson,
Allen Tom, Franklin Tse, Nick Walker, Shane Weeden, and Skylar
Woodward.

This document was produced under the chairmanship of Blaine Cook,
Peter Saint-Andre, Hannes Tschofenig, Barry Leiba, and Derek Atkins.
The area directors included Lisa Dusseault, Peter Saint-Andre, and
Stephen Farrell.

Author's Address

Dick Hardt (editor)  
Microsoft

EMail: dick.hardt@gmail.com  
URI: [http://dickhardt.org/](http://dickhardt.org/)
